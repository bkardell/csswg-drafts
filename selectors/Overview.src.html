<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
 <head>
  <meta charset=utf8>
  <title>Selectors Level 4</title>
  <link href="../default.css" type="text/css" rel="stylesheet">
  <style type="text/css">
    .tprofile td, th { vertical-align: baseline; padding: 0 0.5em; }
    .tprofile th { text-align: right; }
  </style>
  <link href="http://www.w3.org/StyleSheets/TR/W3C-WD.css" type="text/css" rel="stylesheet">
 </head>
 <body>
  <div class="head">
   <!--logo-->

   <h1 id="title">Selectors Level 4</h1>

   <h2 class="no-num no-toc">[LONGSTATUS] [DATE]</h2>

   <dl>
    <dt>This version:
    <dd><a href="[VERSION]">
                 http://www.w3.org/TR/[YEAR]/ED-[SHORTNAME]-[CDATE]/</a>

    <dt>Editor's draft:
    <dd><a href="http://dev.w3.org/csswg/selectors4/">
                 http://dev.w3.org/csswg/selectors4/</a>

    <dt>Latest version of Selectors Level 4:
    <dd><a href="http://www.w3.org/TR/selectors4/">
                 http://www.w3.org/TR/selectors4/</a>

    <dt>Latest Selectors specification:
    <dd><a href="http://www.w3.org/TR/selectors/">
                 http://www.w3.org/TR/selectors/</a>

    <dt>Previous version:
    <dd><a href="http://www.w3.org/TR/2011/WD-selectors4-20110929/">
                 http://www.w3.org/TR/2011/WD-selectors4-20110929/</a>

  <dt>Feedback:
    <dd><a href="mailto:www-style@w3.org?subject=%5Bselectors4%5D%20feedback">www-style@w3.org</a>
        with subject line &ldquo;<kbd>[selectors4] <var>&hellip; message topic &hellip;</var></kbd>&rdquo;
        (<a rel="discussion" href="http://lists.w3.org/Archives/Public/www-style/">archives</a>)

    <dt>Editors:
    <dd class="vcard"><a class="url fn" href="http://fantasai.inkedblade.net/contact">Elika J. Etemad</a> (Mozilla)
    <dd class='vcard'>
      <a class='url fn' href="http://www.xanthir.com/contact/">Tab Atkins Jr.</a> (<span class='org'>Google</span>)

    <dt>Previous Editors:
    <dd class="vcard"><a lang="tr" class="url fn" href="http://www.tantek.com/">Tantek &Ccedil;elik</a> (Microsoft)
    <dd class="vcard"><span class="fn">Daniel Glazman</span> (Disruptive Innovations SARL)
    <dd class="vcard"><span class="fn">Ian Hickson</span> (Opera Softare ASA)
    <dd class="vcard"><span class="fn">Peter Linss</span> (Netscape/AOL)
    <dd class="vcard"><span class="fn">John Williams</span> (Quark, Inc.)
   </dl>

   <!--copyright-->

   <hr title="Separator for header">

  </div>

<h2 class="no-num no-toc" id="abstract">
Abstract</h2>

  <p><em>Selectors</em> are patterns that match against elements in a
  tree, and as such form one of several technologies that can be used
  to select nodes in a document. Selectors have been optimized for
  use with HTML and XML, and are designed to be usable in
  performance-critical code. They are a core component of
  <abbr title="Cascading Style Sheets">CSS</abbr> (Cascading
  Style Sheets), which uses Selectors to bind style properties to
  elements in the document.

  <p>Selectors Level 4 describes the selectors that already exist in
  [[!SELECT]], and further introduces new selectors for CSS and
  other languages that may need them.

  <h2 class="no-num no-toc" id="status">Status of this Document</h2>

  <!--status-->

  <p>This module is a somewhat-unstable Working Draft.
  <strong>If you are looking for a stable Selectors specification, use
  <a href="http://www.w3.org/TR/css3-selectors/">Selectors 3</a>.</strong>
  Read the <a href="http://www.w3.org/TR/CSS/">CSS Snapshot</a> for
  an overview of the CSS development process.
  See the <a href="#overview">Selectors Overview</a> for a summary of
  additions to level 3.

  <p>The following features are at-risk and may be dropped during the CR period
  if there is not sufficient implementer interest:
  the reference combinator,
  the column combinator,
  the '':drop()'' pseudo-class.

  <h2 class="no-num no-toc" id="contents">Table of Contents</h2>
  <!--toc-->

<h2 id="context">
Introduction</h2>

  <p><em>This section is not normative.</em>

  <p>
    A selector is a boolean predicate
    that takes an element in a tree structure
    and tests whether the element matches the selector or not.

  <p>
    These expressions may be used for many things:

  <ul>
    <li>
      directly on an element to test whether it matches some criteria,
      such as in the <code>Element.matches()</code> function defined in [[SELECTORS-API2]]

    <li>
      applied to an entire tree of elements
      to filter it into a set of elements that match the criteria,
      such as in the <code>document.findAll()</code> function defined in [[SELECTORS-API2]]
      or the selector of a CSS style rule.

    <li>
      used "in reverse" to generate markup that would match a given selector,
      such as in <a href="http://haml.info/">HAML</a> or <a href="http://en.wikipedia.org/wiki/Zen_Coding">Zen Coding</a>
  </ul>


  <p>
    Selectors Levels 1, 2, and 3 are defined as the subsets of selector
    functionality defined in the <a href="http://www.w3.org/TR/REC-CSS1">CSS1</a>,
    <a href="http://www.w3.org/TR/CSS21/">CSS2.1</a>, and
    <a href="http://www.w3.org/TR/css3-selectors/">Selectors Level 3</a>
    specifications, respectively. This module defines Selectors Level 4.

<h3 id="placement">Module Interactions</h3>

  <p>This module replaces the definitions of
    and extends the set of selectors defined for CSS in [[SELECT]] and [[CSS21]].

  <p>
    Pseudo-element selectors,
    which define abstract elements in a rendering tree,
    are not part of this specification:
    their generic syntax is described here,
    but, due to their close integration with the rendering model and irrelevance to other uses such as DOM queries,
    they will be defined in other modules.

<h2 id="overview">
Selectors Overview</h2>

  <p><em>This section is non-normative, as it merely summarizes the
  following sections.</em>

  <p>A Selector represents a structure. This structure can be used as a
  condition (e.g. in a CSS rule) that determines which elements a
  selector matches in the document tree, or as a flat description of the
  HTML or XML fragment corresponding to that structure.

  <p>Selectors may range from simple element names to rich contextual
  representations.

  <p>The following table summarizes the Selector syntax:

  <table class="data">
    <col class="pattern">
    <col class="meaning">
    <col class="section">
    <col class="level">
  <thead>
    <tr>
      <th>Pattern
      <th>Represents
      <th>Section
      <th>Level
  <tbody>
    <tr>
      <td><code>*</code>
      <td>any element
      <td><a href="#universal-selector">Universal selector</a>
      <td>2
    <tr>
      <td><code>E</code>
      <td>an element of type E
      <td><a href="#type-selectors">Type (tag name) selector</a>
      <td>1
  <tbody>
    <tr>
      <td><code>E:not(<var>s1</var>, <var>s2</var>)</code>
      <td>an E element that does not match either <i>compound selector</i> <var>s1</var>
          or <i>compound selector</i> <var>s2</var>
      <td><a href="#negation">Negation pseudo-class</a>
      <td>3/4
    <tr>
      <td><code>E:matches(<var>s1</var>, <var>s2</var>)</code>
      <td>an E element that matches <i>compound selector</i> <var>s1</var>
          and/or <i>compound selector</i> <var>s2</var>
      <td><a href="#matches">Matches-any pseudo-class</a>
      <td>4
  <tbody>
    <tr>
      <td><code>E.warning</code>
      <td>an E element belonging to the class <code>warning</code>
          (the document language specifies how class is determined).
      <td><a href="#class-html">Class selectors</a>
      <td>1
    <tr>
      <td><code>E#myid</code>
      <td>an E element with ID equal to <code>myid</code>.
      <td><a href="#id-selectors">ID selectors</a>
      <td>1
    <tr>
      <td><code>E[foo]</code>
      <td>an E element with a <code>foo</code> attribute
      <td><a href="#attribute-selectors">Attribute selectors</a>
      <td>2
    <tr>
      <td><code>E[foo="bar"]</code>
      <td>an E element whose <code>foo</code> attribute value is
          exactly equal to <code>bar</code>
      <td><a href="#attribute-selectors">Attribute selectors</a>
      <td>2
    <tr>
      <td><code>E[foo="bar" i]</code>
      <td>an E element whose <code>foo</code> attribute value is
          exactly equal to any (ASCII-range) case-permutation of <code>bar</code>
      <td><a href="#attribute-case">Attribute selectors: Case-sensitivity</a>
      <td>4
    <tr>
      <td><code>E[foo~="bar"]</code>
      <td>an E element whose <code>foo</code> attribute value is
          a list of whitespace-separated values, one of which is
          exactly equal to <code>bar</code>
      <td><a href="#attribute-selectors">Attribute selectors</a>
      <td>2
    <tr>
      <td><code>E[foo^="bar"]</code>
      <td>an E element whose <code>foo</code> attribute value
          begins exactly with the string "bar"
      <td><a href="#attribute-selectors">Attribute selectors</a>
      <td>3
    <tr>
      <td><code>E[foo$="bar"]</code>
      <td>an E element whose <code>foo</code> attribute value
          ends exactly with the string <code>bar</code>
      <td><a href="#attribute-selectors">Attribute selectors</a>
      <td>3
    <tr>
      <td><code>E[foo*="bar"]</code>
      <td>an E element whose <code>foo</code> attribute value
          contains the substring <code>bar</code>
      <td><a href="#attribute-selectors">Attribute selectors</a>
      <td>3
    <tr>
      <td><code>E[foo|="en"]</code>
      <td>an E element whose <code>foo</code> attribute value is
          a hyphen-separated list of values beginning with <code>en</code>
      <td><a href="#attribute-selectors">Attribute selectors</a>
      <td>2
  <tbody>
    <tr>
      <td><code>E:dir(ltr)</code>
      <td>an element of type E in with left-to-right directionality
        (the document language specifies how directionality is determined)
      <td><a href="#dir-pseudo">The :dir() pseudo-class</a>
      <td>4
    <tr>
      <td><code>E:lang(zh, *-hant)</code>
      <td>an element of type E tagged as being either in Chinese
        (any dialect or writing system)
        or othewise written with traditional Chinese characters
      <td><a href="#lang-pseudo">The :lang() pseudo-class</a>
      <td>2/4
  <tbody>
    <tr>
      <td><code>E:any-link</code>
      <td>an E element being the source anchor of a hyperlink
      <td><a href="#any-link-pseudo">The hyperlink pseudo-class</a>
      <td>4
    <tr>
      <td><code>E:link</code>
      <td>an E element being the source anchor of a hyperlink
          of which the target is not yet visited
      <td><a href="#link">The link history pseudo-classes</a>
      <td>1
    <tr>
      <td><code>E:visited</code>
      <td>an E element being the source anchor of a hyperlink
          of which the target is already visited
      <td><a href="#link">The link history pseudo-classes</a>
      <td>1
    <tr>
      <td><code>E:local-link</code>
      <td>an E element being the source anchor of a hyperlink
          of which the target is the current document
      <td><a href="#local-pseudo">The local link pseudo-class</a>
      <td>4
    <tr>
      <td><code>E:local-link(0)</code>
      <td>an E element being the source anchor of a hyperlink
          of which the target is within the current domain
      <td><a href="#local-pseudo">The local link pseudo-class</a>
      <td>4
    <tr>
      <td><code>E:target</code>
      <td>an E element being the target of the referring URL
      <td><a href="#target-pseudo">The target pseudo-class</a>
      <td>3
    <tr>
      <td><code>E:scope</code>
      <td>an E element being a designated reference element
      <td><a href="#scope-pseudo">The scope pseudo-class</a>
      <td>4
  <tbody>
    <tr>
      <td><code>E:current</code>
      <td>an E element that is currently presented in a time-dimensional canvas
      <td><a href="#time-pseudos">Time-dimensional Pseudo-classes</a>
      <td>4
    <tr>
      <td><code>E:current(<var>s</var>)</code>
      <td>an E element that is the deepest <code>:current</code> element that
          matches selector <var>s</var>
      <td><a href="#time-pseudos">Time-dimensional Pseudo-classes</a>
      <td>4
    <tr>
      <td><code>E:past</code>
      <td>an E element that is in the past in a time-dimensional canvas
      <td><a href="#time-pseudos">Time-dimensional Pseudo-classes</a>
      <td>4
    <tr>
      <td><code>E:future</code>
      <td>an E element that is in the future in a time-dimensional canvas
      <td><a href="#time-pseudos">Time-dimensional Pseudo-classes</a>
      <td>4
  <tbody>
    <tr>
      <td><code>E:active</code>
      <td>an E element that is in an activated state
      <td><a href="#useraction-pseudos">The user action pseudo-classes</a>
      <td>1
    <tr>
      <td><code>E:hover</code>
      <td>an E element that is under the cursor,
          or that has a descendant under the cursor
      <td><a href="#useraction-pseudos">The user action pseudo-classes</a>
      <td>2
    <tr>
      <td><code>E:focus</code>
      <td>an E element that has user input focus
      <td><a href="#useraction-pseudos">The user action pseudo-classes</a>
      <td>2
    <tr>
      <td><code>E:active-drop</code>
      <td>an E element that will receive the item currently being dragged
      <td><a href="#drag-pseudos">The drag-and-drop pseudo-classes</a>
      <td>4
    <tr>
      <td><code>E:valid-drop</code>
      <td>an E element that could receive the item currently being dragged
      <td><a href="#drag-pseudos">The drag-and-drop pseudo-classes</a>
      <td>4
    <tr>
      <td><code>E:invalid-drop</code>
      <td>an E element that cannot receive the item currently being dragged, but could receive some other item
      <td><a href="#drag-pseudos">The drag-and-drop pseudo-classes</a>
      <td>4
  <tbody>
    <tr>
      <td><code>E:enabled<br>E:disabled</code>
      <td>a user interface element E that is enabled or disabled, respectively
      <td><a href="#enableddisabled">The :enabled and :disabled pseudo-classes</a>
      <td>3
    <tr>
      <td><code>E:read-only</code><br><code>E:read-write</code>
      <td>a user interface element E that
      <td><a href="#rw-pseudos">The mutability pseudo-classes</a>
      <td>3-UI/4
    <tr>
      <td><code>E:placeholder-shown</code>
      <td>an input control currently showing placeholder text
      <td><a href="#rw-pseudos">The placeholder-shown pseudo-class</a>
      <td>3-UI/4
    <tr>
      <td><code>E:default</code>
      <td>a user interface element E that
      <td><a href="#default-pseudo">The default option pseudo-class :default</a>
      <td>3-UI/4
    <tr>
      <td><code>E:checked</code>
      <td>a user interface element E that is checked/selected
         (for instance a radio-button or checkbox)
      <td><a href="#checked">The selected-option pseudo-class</a>
      <td>3
    <tr>
      <td><code>E:indeterminate</code>
      <td>a user interface element E that is in an indeterminate state
          (neither checked nor unchecked)
      <td><a href="#indeterminate">The indeterminate-value pseudo-class</a>
      <td>4
    <tr>
      <td><code>E:valid</code><br><code>E:invalid</code>
      <td>a user-input element E that
      <td><a href="#range-pseudos">The validity pseudo-classes</a>
      <td>3-UI/4
    <tr>
      <td><code>E:in-range</code><br><code>E:out-of-range</code>
      <td>a user-input element E whose value is in-range/out-of-range
      <td><a href="#range-pseudos">The range pseudo-classes</a>
      <td>3-UI/4
    <tr>
      <td><code>E:required</code><br><code>E:optional</code>
      <td>a user-input element E that requires/does not require input
      <td><a href="#opt-pseudos">The optionality pseudo-classes</a>
      <td>3-UI/4
    <tr>
      <td><code>E:required</code><br><code>E:optional</code>
      <td>a user-input element E with incorrect input
      <td><a href="#opt-pseudos">The optionality pseudo-classes</a>
      <td>4
  <tbody>
    <tr>
      <td><code>E:root</code>
      <td>an E element, root of the document
      <td><a href="#structural-pseudos">Structural pseudo-classes</a>
      <td>3
    <tr>
      <td><code>E:empty</code>
      <td>an E element that has no children (not even text nodes)
      <td><a href="#structural-pseudos">Structural pseudo-classes</a>
      <td>3
    <tr>
      <td><code>E:blank</code>
      <td>an E element that has no content except maybe white space
      <td><a href="#structural-pseudos">Structural pseudo-classes</a>
      <td>4
    <tr>
      <td><code>E:nth-child(<var>n</var>)</code>
      <td>an E element, the <var>n</var>-th child of its parent
      <td><a href="#structural-pseudos">Structural pseudo-classes</a>
      <td>3
    <tr>
      <td><code>E:nth-last-child(<var>n</var>)</code>
      <td>an E element, the <var>n</var>-th child of its parent,
          counting from the last one
      <td><a href="#structural-pseudos">Structural pseudo-classes</a>
      <td>3
    <tr>
      <td><code>E:first-child</code>
      <td>an E element, first child of its parent
      <td><a href="#structural-pseudos">Structural pseudo-classes</a>
      <td>2
    <tr>
      <td><code>E:last-child</code>
      <td>an E element, last child of its parent
      <td><a href="#structural-pseudos">Structural pseudo-classes</a>
      <td>3
    <tr>
      <td><code>E:only-child</code>
      <td>an E element, only child of its parent
      <td><a href="#structural-pseudos">Structural pseudo-classes</a>
      <td>3
    <tr>
      <td><code>E:nth-of-type(<var>n</var>)</code>
      <td>an E element, the <var>n</var>-th sibling of its type
      <td><a href="#structural-pseudos">Structural pseudo-classes</a>
      <td>3
    <tr>
      <td><code>E:nth-last-of-type(<var>n</var>)</code>
      <td>an E element, the <var>n</var>-th sibling of its type,
          counting from the last one
      <td><a href="#structural-pseudos">Structural pseudo-classes</a>
      <td>3
    <tr>
      <td><code>E:first-of-type</code>
      <td>an E element, first sibling of its type
      <td><a href="#structural-pseudos">Structural pseudo-classes</a>
      <td>3
    <tr>
      <td><code>E:last-of-type</code>
      <td>an E element, last sibling of its type
      <td><a href="#structural-pseudos">Structural pseudo-classes</a>
      <td>3
    <tr>
      <td><code>E:only-of-type</code>
      <td>an E element, only sibling of its type
      <td><a href="#structural-pseudos">Structural pseudo-classes</a>
      <td>3
    <tr>
      <td><code>E:nth-match(<var>n</var> of <var title=''>selector</var>)</code>
      <td>an E element, the <var>n</var>-th sibling matching <var title=''>selector</var>
      <td><a href="#structural-pseudos">Structural pseudo-classes</a>
      <td>4
    <tr>
      <td><code>E:nth-last-match(<var>n</var> of <var title=''>selector</var>)</code>
      <td>an E element, the <var>n</var>-th sibling matching <var title=''>selector</var>,
          counting from the last one
      <td><a href="#structural-pseudos">Structural pseudo-classes</a>
      <td>4
  <tbody>
    <tr>
      <td><code>E F</code>
      <td>an F element descendant of an E element
      <td><a href="#descendant-combinators">Descendant combinator</a>
      <td>1
    <tr>
      <td><code>E > F</code>
      <td>an F element child of an E element
      <td><a href="#child-combinators">Child combinator</a>
      <td>2
    <tr>
      <td><code>E + F</code>
      <td>an F element immediately preceded by an E element
      <td><a href="#adjacent-sibling-combinators">Next-sibling combinator</a>
      <td>2
    <tr>
      <td><code>E ~ F</code>
      <td>an F element preceded by an E element
      <td><a href="#general-sibling-combinators">Following-sibling combinator</a>
      <td>3
    <tr>
      <td><code>E /foo/ F</code>
      <td>an F element ID-referenced by an E element's <code>foo</code> attribute
      <td><a href="#idref-combinators">Reference combinator</a>
      <td>4
    <tr>
      <td><code>E:has(F)</code>
      <td>an E element ancestor of an F element
      <td><a href="#subject">Determining the subject of a selector</a> +
          <a href="#child-combinators">Child combinator</a>
      <td>4
  <tbody>
    <tr>
      <td><code>F || E</code>
      <td>an E element that represents a cell in a grid/table
          belonging to a column represented by an element F
      <td><a href="#table-pseudos">Grid-Structural pseudo-classes</a>
      <td>4
    <tr>
      <td><code>E:nth-column(<var>n</var>)</code>
      <td>an E element that represents a cell belonging to the
          <var>n</var>th column in a grid/table
      <td><a href="#table-pseudos">Grid-Structural pseudo-classes</a>
      <td>4
    <tr>
      <td><code>E:nth-last-column(<var>n</var>)</code>
      <td>an E element that represents a cell belonging to the
          <var>n</var>th column in a grid/table, counting from the last one
      <td><a href="#table-pseudos">Grid-Structural pseudo-classes</a>
      <td>4
  </tbody></table>

  <p class="note">Some Level 4 selectors (noted above as "3-UI") were
    introduced in [[CSS3UI]].

<h3 id="profiles">
<i>Fast</i> vs <i>Complete</i> Selector Profiles</h3>

  <p>
    Selectors are used in many different contexts,
    with wildly varying performance characteristics.
    Some powerful selectors are unfortunately too slow
    to realistically include in the more performance-sensitive contexts.
    To accommodate this, two profiles of the Selectors spec are defined:

  <dl>
    <dt><dfn id='fast-profile'>fast</dfn>
    <dd>
      The <i>fast</i> profile is appropriate for use in any context,
      including dynamic browser CSS selector matching.
      It includes every selector defined in this document,
      except for:

      <ul>
        <li><i>Combinators</i> within <code>:matches()</code>, <code>:not()</code>, <code>:nth-match()</code>, and <code>:nth-last-match()</code>.
          <p class='issue'>We are considering whether this restriction should be lifted.
        <li>The <a href="#idref-combinators">reference combinator</a>
        <li>The <a href="#subject">:has() pseudo-class</a>
      </ul>

    <dt><dfn id='complete-profile'>complete</dfn>
    <dd>
      The <i>complete</i> profile is appropriate for contexts which aren't extremely performance sensitive.
      For example, implementations of the Selectors API specification [[SELECTORS-API]] should use the ''complete'' profile.
      It includes all of the selectors defined in this document.
  </dl>

  <p>CSS implementations conformant to Selectors Level 4 must use the ''fast'' profile for CSS selection.

  <p class='issue'>
    The categorization of things into the "fast" or "complete" profiles needs implementor review.
    If some things currently not in the fast profile can reasonably be done in CSS Selectors,
    we should move them.


<h2 id="syntax">
Selector Syntax and Structure</h2>

<h3 id="structure">
Structure and Terminology</h3>

  <p>The term <dfn>selector</dfn> can refer to a <i>simple selector</i>,
    <i>compound selector</i>, <i>complex selector</i>, or <i>selector list</i>.

  <p>A <i>selector list</i> is a comma-separated list of <i>selectors</i>;
    see <a href="#grouping">Selector Lists</a>.

  <p>A <dfn id="complex">complex selector</dfn> is a chain of one
  or more <i>compound selectors</i>
  separated by <i>combinators</i>.

  <p>A <dfn id="compound">compound selector</dfn>
  is a chain of <i>simple selectors</i>
  that are not separated by a <i>combinator</i>. It
  always begins with a <i>type selector</i> or a
  (possibly implied) <i>universal selector</i>.
  No other type selector or universal selector is allowed in the sequence.

  <p>
    A <dfn id="simple">simple selector</dfn> is either a
    <i>type selector</i>,
    <i>universal selector</i>,
    <i>attribute selector</i>,
    <i>class selector</i>,
    <i>ID selector</i>,
    or <i>pseudo-class</i>.

  <p>A <dfn>combinator</dfn> is punctuation that represents a particular
  kind of relationship between the <i>compound selectors</i> on either side.
  Combinators in Selectors level 4 include: whitespace, &quot;greater-than
  sign&quot; (U+003E, <code>></code>), &quot;plus sign&quot; (U+002B,
  <code>+</code>) and &quot;tilde&quot; (U+007E, <code>~</code>).
  <a href="#whitespace">White space</a> may appear between a combinator
  and the simple selectors around it.

  <p>An empty selector, containing no <i>compound selector</i>, is an
  <a href="#invalid">invalid selector</a>.

<h3 id='evaluating-selectors'>
Evaluating a Selector</h3>

  <p>A <i>selector</i> is evaluated against some initial list of elements,
  as determined by the context that the selector is evaluated in:
  the <dfn data-export>selector match list</dfn>.
  The selector is processed from left to right in order,
  with <i>simple selectors</i> filtering the <i>selector match set</i>,
  and <i>combinators</i> changing the <i>selector match set</i> into something new.
  When this process is done, the elements in the <i>selector match set</i>
  are the elements said to match the selector.

  <p>For example, to evaluate the selector "div > i.name" against a document,
  the <i>selector match list</i> is first set to all the elements in the entire document.
  Then, the "div" type selector is evaluated, filtering the <i>selector match list</i>
  to only contain elements with a tagname of "div".
  Then, the ">" child combinator is evaluated, transforming the <i>selector match list</i>
  by replacing each element currently in it with the element's children.
  Then, the "i" type selector is evaluated, filtering the <i>selector match list</i>
  to only contain elements with a tagname of "i".
  Finally, the ".name" class selector is evaluated, filter the <i>selector match list</i>
  to only contain elements with a class of "name".

  <p class='note'>
    Note that many implementations of selectors instead evaluate them right to left,
    as it's more efficient to do so in many cases.
    This, as usual, is completely valid,
    as long as it results in the same elements being returned
    as the spec's algorithm would.

  <p>Each context that a selector can be evaluated in
  must define the <dfn data-export>initial selector match list</dfn>,
  the list of elements that every selector in that context begins with.

  <p>For HTML,
  when evaluating a selector against a document,
  the <i>initial selector match list</i>
  is the root element and all of its descendants,
  ordered by a pre-order traversal.


<h3 id='data-model'>
Data Model</h3>

  <p>Selectors are matched against an <dfn data-export>element tree</dfn>,
  which is an abstract tree structure consisting of elements.

  Each element may have any of:

  <ul>
    <li>A type, which is a string.
    <li>An ID, which is a string.
    <li>Classes, which are strings.
    <li>Attributes, which are pairs of strings consisting of an attribute name and an attribute value.
    <li>A list of child elements.
    <li>Arbitrary additional information,
      which isn't directly accessible,
      but can be used in the matching of pseudo-classes and pseudo-elements.
  </ul>

  <p>In HTML,
  the DOM is used as the <i>element tree</i>.
  Each DOM element is an element in the <i>element tree</i>,
  with the DOM element's tagname as the type,
  and its ID, class list, attributes, and child elements
  as the ID, classes, attributes, and child elements in the <i>element tree</i>.
  The rest of the information in the DOM is also accessible
  as the arbitrary additional information in the <i>element tree</i>.

<h3 id="subject">
Determining the Subject of a Selector</h3>

  <p>The elements of a document tree that are represented by a selector
  are the <dfn title="subject">subjects</dfn> of the selector.

  <p>By default, the subjects of a selector are the elements represented
  by the last <i>compound selector</i> in the selector.
  Thus a selector consisting of a single <i>compound selector</i>
  represents any element satisfying its requirements
  Prepending another <i>compound selector</i> and a combinator
  to a sequence imposes additional matching constraints,
  so the subjects of the selector are always a subset of
  the elements represented by the last <i>compound selector</i>.

  <p>As a feature of the <i>complete</i> Selectors profile,
  the subject of the selector can be explicitly identified
  by using the <code>:has()</code> pseudo-class
  to one of the <i>compound selectors</i> in a selector.
  Although the element structure that the selector represents is the same
  with or without the pseudo-class, indicating the subject in this way
  can change which <i>compound selector</i> represents the subject in that structure.

  <div class="example">
  <p>For example, the following selector represents a list item <code>LI</code>
    unique child of an ordered list <code>OL</code>:
    <pre>OL > LI:only-child</pre>
    <p>However the following one represents an ordered list <code>OL</code>
    having a unique child, that child being a <code>LI</code>:
    <pre>OL:has( > LI:only-child )</pre>
    <p>The tree structures represented by these two selectors are the same,
    but the subjects of the selectors are not.
  </div>



<h3 id="scoping">
Scoped Selectors</h3>

  <p>Some host applications may choose to <dfn data-export title="scope | scoped selector">scope</dfn> selectors
  to a particular subtree or fragment of the document.
  The root of the scoping subtree is called the <dfn data-export>scoping root</dfn>,
  and may be either a true element (the <dfn data-export>scoping element</dfn>)
  or a <dfn data-export title="virtual scoping root">virtual</dfn> one (such as a <code>DocumentFragment</code>).

  <p>There are two methods of scoping selectors:

  <dl>
    <dt><dfn data-export title="scope-contained | scope-contained selector">scope-contained selectors</dfn>
    <dd>
      With this method of scoping, selectors match as if
      the <i>scoping root</i> were the root of the document:
      all <i>compound selectors</i> must be represented within the scope.
      (The <code>:root</code> pseudo-class, however,
      still only matches the actual root of the document.)

    <dt><dfn data-export title="scope-filtered | scope-filtered selector">scope-filtered</dfn> selectors
    <dd>
      With this method of scoping, a selector matches if
      the <i>subject</i> of the selector is within the scope,
      even if other components of the selector are outside the scope.
      (A <i>scoping element</i> is considered to be in scope.)
  </dl>

  <div class='example'>
    <p>
      For example,
      the <code>element.querySelector()</code> function defined in [[SELECTORS-API2]]
      allows the author to define a <i>scope-filtered</i> selector.

    <p>
      On the other hand, the selectors within an [[HTML5]] scoped stylesheet
      define <i>scope-contained</i> selectors.
  </div>

  <p>Unless otherwise specified,
  the <i>scoping root</i> also forms the <i>reference element set</i>
  and matches the <code>:scope</code> pseudo-class.

<h3 id="relative">
Relative Selectors</h3>

  <p>
    Certain contexts may accept <dfn title="relative selector | relative | scope-relative">relative selectors</dfn>,
    which are a shorthand for selectors that represent elements relative to a <i>reference element</i>
    (i.e. an element that matches <code>:scope</code>).
    In a <i>relative selector</i>,
    “<code>:scope</code> ” (the <code>:scope</code> pseudo-class followed by a space)
    is implied at the beginning of each <i>complex selector</i>
    that does not already contain the <code>:scope</code> pseudo-class.
    This allows the selector to begin syntactically with a <i>combinator</i>.
    However, it must be <a href="#absolutize">absolutized</a> before matching.

  <p>
    Relative selectors, once absolutized, can additionally be <i>scope-contained</i>
    (such as within the <code>::distributed()</code> pseudo-class [[SHADOWDOM]])
    or <i>scope-filtered</i>.

<h4 id='absolutizing'>
Absolutizing a Relative Selector</h4>

  <p>
    To <dfn id='absolutize'>absolutize a relative selector</dfn>:

  <p>
    If the <i>reference element set</i> is empty or consists of one or more elements:

  <ol>
    <li>
      If the selector starts with a <i>combinator</i> other than the <i>descendant combinator</i>,
      prepend <code>:scope</code> as the initial <i>compound selector</i>.

    <li>
      Otherwise, if the selector does not contain any instance of the <code>:scope</code> pseudo-class
      (either at the top-level or as an argument to a functional pseudo-class),
      prepend <code>:scope</code> followed by the <i>descendant combinator</i>.

    <li>
      Otherwise, the selector is already absolute.
  </ol>

  <p class='issue'>
    The above algorithm is different from Selectors API: its step 2, which bailed if the reference element set was empty, has been removed.
    This is because handling an explicitly empty list should return nothing;
    if a reference element set was not given at all,
    Selectors API 2 should be amended to say that the selector must be absolute already.
    (Broken example: doing <code>document.find('img', [list-of-links]))</code> finds images that are descendants of links normally,
    but instead finds all images in the document if the list-of-links is empty.)

  <p>
    Otherwise, if the <i>reference element set</i> consists of only a <i>virtual scoping root</i>:

  <ol>
    <li>
      If the selector starts with a <i>child combinator</i>,
      remove the child combinator.
      The selector is now absolute,
      with the additional constraint that the first compound selector in the selector
      only matches elements without a parent.

    <li>
      Otherwise, if the selector starts with any combinator other than the <i>descendant combinator</i>,
      change the selector to '':not(*)''.
      <span class='note'>This is the shortest selector that is valid, but guaranteed to match nothing.</span>

    <li>
      Otherwise, the selector is already absolute.
  </ol>

  <p>
    Otherwise, this is a spec error.  Please report it to the relevant standards body.

  <p>
    To <dfn id='absolutize-list'>absolutize a relative selector list</dfn>,
    absolutize each relative selector in the list.


<h3 id="pseudo-classes">
Pseudo-classes</h3>

  <p>The <dfn>pseudo-class</dfn> concept is introduced to permit selection based on
  information that lies outside of the document tree
  or that can be awkward or impossible to express using the other simple selectors.

  <p>A <i>pseudo-class</i> always consists of a “colon”
  (<code>:</code>) followed by the name of the <i>pseudo-class</i> and, for
  <dfn>functional pseudo-classes</dfn>, by one or more arguments between parentheses
  (similar to CSS functions).
  White space is optionally allowed between the parentheses and the argument,
  but not between the pseudo-class name and the parentheses.
  If arguments are separated by commas, white space is optionally allowed
  before/after each comma.

  <p><i>Pseudo-classes</i> are allowed in all <i>compound selectors</i> contained in a selector.
  <i>Pseudo-classes</i> are allowed anywhere in a <i>compound selector</i>
  after the leading type selector or (possibly omitted) universal selector.
  <i>Pseudo-class</i> names are <a href="#case-sensitive">ASCII case-insensitive</a>.
  Some <i>pseudo-classes</i> are mutually exclusive
  (such that a <i>compound selector</i> containing them, while valid, will never match anything),
  while others can apply simultaneously to the same element.
  <i>Pseudo-classes</i> may be dynamic,
  in the sense that an element can acquire or lose a pseudo-class
  while a user interacts with the document.

  <p>Dynamic <i>pseudo-classes</i> classify elements on characteristics
  other than their name, attributes, or content,
  but rather on characteristics that cannot be deduced from the document tree.
  They do not appear in or modify the document source or document tree.

<h3 id="pseudo-elements">Pseudo-elements</h3>

  <p><dfn id='pseudo-element' title="pseudo-element">Pseudo-elements</dfn> create abstractions about the document tree
  beyond those specified by the document language.
  For instance, document languages do not offer mechanisms to access
  the first letter or first line of an element's content.
  <i>Pseudo-elements</i> allow authors to refer
  to this otherwise inaccessible information.
  <i>Pseudo-elements</i> may also provide authors a way
  to refer to content that does not exist in the source document
  (e.g., the <code>::before</code> and <code>::after</code> <i>pseudo-elements</i>
  give access to generated content in CSS [[CSS21]]).

  <p>A <i>pseudo-element</i> is made of two colons (<code>::</code>)
  followed by the name of the <i>pseudo-element</i>.
  <i>Pseudo-element</i> names are <a href="#case-sensitive">ASCII case-insensitive</a>.

  <p>This <code>::</code> notation was chosen in order to establish
  a discrimination between <i>pseudo-classes</i> (which subclass existing elements)
  and <i>pseudo-elements</i> (which are elements not represented in the document tree).
  However, for compatibility with existing style sheets,
  user agents must also accept the previous one-colon notation
  for <i>pseudo-elements</i> introduced in CSS levels 1 and 2
  (namely, <code>:first-line</code>, <code>:first-letter</code>,
  <code>:before</code> and <code>:after</code>).
  This compatibility notation is not allowed any other <i>pseudo-elements</i>.

  <p class="note">A future version of this specification may allow
  multiple pseudo-elements per selector.

  <p>Syntactically, a <i>pseudo-element</i> immediately follows
  the <i>compound selector</i> representing its <dfn data-export>originating element</dfn>,
  i.e. the element to which it is associated.
  Unless otherwise overridden by the definition of the <i>pseudo-element</i>:
  <ul>
    <li>only one <i>pseudo-element</i> may appear per <i>complex selector</i>
    <li>the <i>pseudo-element</i> must appear after the <i>compound selector</i>
      that represents the <a href="#subject">subjects</a> of the selector
    <li>the <i>pseudo-element</i> may appear only if the subject of the selector
      is the last <i>compound selector</i> in the selector.
  </ul>

  <p>A <i>pseudo-element</i> may be immediately followed
  by any combination of the <a href="#useraction-pseudos">user action pseudo-classes</a>,
  in which case the <i>pseudo-element</i> is represented only when it is in the corresponding state.
  Whether these pseudo-classes can match on the <i>pseudo-element</i>
  depends on the <i>pseudo-class</i> and <i>pseudo-element</i>&rdquo;s definitions:
  unless otherwise-specified, none of these <i>pseudo-classes</i>
  will match on the <i>pseudo-element</i>.

  <div class="example">
    <p>For example, the <code>:hover</code> pseudo-class specifies that it
    can apply to any pseudo-element, i.e. <code>::first-line:hover</code>
    will match when the first line is hovered.
    However, since neither <code>:focus</code> nor <code>::first-line</code>
    define that <code>:focus</code> can apply to <code>::first-line</code>,
    the selector <code>::first-line:focus</code> will never match anything.
  </div>

  <p>The host language defines which pseudo-elements exist and their meaning.
  For CSS, [[CSS21]] defines the ::before, ::after, ::first-line and ::first-letter pseudo-elements.

<h3 id="case-sensitive">
Characters and case sensitivity</h3>

  <p>All Selectors syntax is case-insensitive within the ASCII range
  (i.e. [a-z]  and [A-Z] are equivalent),
  except for the following parts,
  which are not under the control of Selectors:
  the case-sensitivity of
  document language element names,
  attribute names,
  and attribute values
  depends on the document language.
  For example,
  <a href="http://www.whatwg.org/html/selectors.html#case-sensitivity">in HTML, element names are case-insensitive</a>,
  but in XML, they are case-sensitive.
  Case sensitivity of namespace prefixes is defined in [[!CSS3NAMESPACE]].
  Case sensitivity of <i>language ranges</i> is defined in the <code>:lang()</code> section.

  <p><dfn id="whitespace">White space</dfn> in Selectors consists of the
  code points SPACE (U+0020), TAB (U+0009), LINE FEED (U+000A),
  CARRIAGE RETURN (U+000D), and FORM FEED (U+000C) can occur in whitespace.
  Other space-like code points, such as EM SPACE (U+2003) and
  IDEOGRAPHIC SPACE (U+3000), are never part of white space.

  <p>Code points in Selectors can be escaped with a backslash
  according to the same <a href="http://www.w3.org/TR/CSS21/syndata.html#characters">escaping rules</a> as CSS. [[!CSS21]]
  Note that escaping a code point "cancels out" any special meaning it may have in Selectors.
  For example, the selector ''#foo>a'' contains a combinator,
  but ''#foo\>a'' instead selects an element with the id <code>foo>a</code>.


<h3 id="namespaces">
Namespaces</h3>

  <p>Certain selectors support namespace prefixes. The
  mechanism by which namespace prefixes are <dfn id="nsdecl">declared</dfn> should
  be specified by the language that uses Selectors. If the language does
  not specify a namespace prefix declaration mechanism, then no prefixes
  are declared. In CSS, namespace prefixes are declared with the
  <a href="http://www.w3.org/TR/css3-namespace/#declaration"><code>@namespace</code></a>
  rule. [[!CSS3NAMESPACE]]

<h3 id="invalid">
Invalid Selectors and Error Handling</h3>

  <p>User agents must observe the rules for handling <dfn title="invalid selector|invalid">invalid selectors</dfn>:
  <ul>
    <li>a parsing error in a selector,
      e.g. an unrecognized token or a token which is not allowed at the current parsing point,
      causes that selector to be invalid
    <li>a simple selector containing an <a href="#namespaces">undeclared namespace prefix</a> is invalid
    <li>a selector containing an invalid simple selector, an invalid combinator
      or an invalid token is invalid.
    <li>a selector list containing an invalid selector is invalid.
  </ul>

  <p>An <i>invalid selector</i> represents nothing.



<h2 id="logical-combination">
Logical Combinations</h2>

<h3 id="grouping">
Selector Lists</h3>

  <p>A comma-separated list of selectors represents the union of all
  elements selected by each of the individual selectors in the
  <dfn>selector list</dfn>.
  (A comma is U+002C.) For example, in CSS when several selectors share
  the same declarations, they may be grouped into a comma-separated
  list. White space may appear before and/or after the comma.

  <div class="example">
    <p>CSS example:
    <p>In this example, we condense three rules with identical
    declarations into one. Thus,
    <pre><!--
    -->h1 { font-family: sans-serif }&#xa;<!--
    -->h2 { font-family: sans-serif }&#xa;<!--
    -->h3 { font-family: sans-serif }</pre>
    <p>is equivalent to:
    <pre>h1, h2, h3 { font-family: sans-serif }</pre>
  </div>

  <p><strong>Warning</strong>: the equivalence is true in this example
  because all the selectors are valid selectors. If just one of these
  selectors were invalid, the entire <i>selector list</i> would be
  invalid. This would invalidate the rule for all three heading
  elements, whereas in the former case only one of the three individual
  heading rules would be invalidated.

  <div class="example">
    <p>Invalid CSS example:
    <pre><!--
    -->h1 { font-family: sans-serif }&#xa;<!--
    -->h2..foo { font-family: sans-serif }&#xa;<!--
    -->h3 { font-family: sans-serif }</pre>
    <p>is not equivalent to:
    <pre>h1, h2..foo, h3 { font-family: sans-serif }</pre>
    <p>because the above selector (<code>h1, h2..foo, h3</code>)
    is entirely invalid and the entire style rule is dropped. (When
    the selectors are not grouped, only the rule for <code>h2..foo</code>
    is dropped.)
  </div>

<h3 id="matches">
The Matches-Any Pseudo-class: <code>:matches()</code></h3>

  <p>The matches-any pseudo-class, <dfn id='matches-pseudo'>:matches()</dfn>,
  is a functional pseudo-class taking a <a href="#grouping">selector list</a>
  as its argument. It represents an element that is represented by its argument.

  <p>In the <i>fast</i> Selectors profile, only lists of <i>compound selectors</i>
  are allowed within <code>:matches()</code>:
  <i>combinators</i> are not allowed.
  In the <i>complete</i> profile,
  full <i>complex selectors</i> are allowed.

  <p>The <code>:matches()</code> pseudo-class may not be nested within itself
  or within <code>:not()</code>:
  <code>:matches(:matches(...))</code> and <code>:not(:matches(...))</code> are invalid.
  Additionally, pseudo-elements cannot be represented by the matches-any pseudo-class;
  they are not valid within <code>:matches()</code>.

  <p>Default namespace declarations do not affect any “implied” universal selectors
    within a <code>:matches()</code> pseudo-class.

  <div class="example">
    <p>For example, following selector matches any element that is being
    hovered or focused, regardless of its namespace. In particular, it
    is not limited to only matching elements in the default namespace
    that are being hovered or focused.
    <pre>*|*:matches(:hover, :focus)</pre>
    <p>The following selector, however, represents only hovered or focused
    elements that are in the default namespace, because it uses an explicit
    universal selector within the <code>:matches()</code> notation:
    <pre>*|*:matches(*:hover, *:focus)</pre>
  </div>

<h3 id="negation">
The Negation Pseudo-class: <code>:not()</code></h3>

  <p>The negation pseudo-class, <dfn id='negation-pseudo'>:not()</dfn>, is a
  functional pseudo-class taking a <a href="#grouping">selector list</a>
  as an argument. It represents an element that is not represented
  by its argument.

  <p>In the <i>fast</i> Selectors profile, only lists of <i>compound selectors</i>
  are allowed within <code>:not()</code>:
  <i>combinators</i> are not allowed.
  In the <i>complete</i> profile,
  full <i>complex selectors</i> are allowed.

  <p class="note">In Selectors Level 3,
  only a single <i>simple selector</i> was allowed as the argument to <code>:not()</code>.

  <p>A negation may not be nested within itself or within <code>:matches()</code>:
  <code>:not(:not(...))</code> and <code>:matches(:not(...))</code> are invalid.
  Additionally, pseudo-elements cannot be represented by the negation pseudo-class;
  they are not valid within <code>:not()</code>.

  <div class="example">
    <p>For example, the following selector matches all <code>button</code>
    elements in an HTML document that are not disabled.
    <pre>button:not([DISABLED])</pre>
    <p>The following selector represents all but <code>FOO</code>
    elements.
    <pre>*:not(FOO)</pre>
    <p>The following compound selector represents all HTML elements
    except links.
    <pre>html|*:not(:link):not(:visited)</pre>
  </div>

  <p>Default namespace declarations do not affect the subject of any selector
  within a negation pseudo-class unless the argument is an explicit universal
  selector or a type selector. (See <a href="#matches"><code>:matches()</code></a>
  for examples.)

  <p class="note"><strong>Note</strong>: the :not() pseudo allows
  useless selectors to be written.  For instance <code>:not(*|*)</code>,
  which represents no element at all, or <code>foo:not(bar)</code>,
  which is equivalent to <code>foo</code> but with a higher
  specificity.

<h2 id="elemental-selectors">
Elemental selectors</h2>

<h3 id="type-selectors">
Type (tag name) selector</h3>

  <p>A <dfn>type selector</dfn> is the name of a document language
  element type written using the syntax of
  <a href="http://www.w3.org/TR/css3-namespace/#css-qnames">CSS qualified
  names</a> [[!CSS3NAMESPACE]]. A type selector represents
  an instance of the element type in the document tree.

  <div class="example">
   <p>Example:
   <p>The following selector represents an <code>h1</code> element in the document tree:
   <pre>h1</pre>
  </div>

<h4 id="typenmsp">
Type selectors and namespaces</h4>

  <p>Type selectors allow an optional namespace component: a namespace
  prefix that has been previously <a href="#nsdecl">declared</a> may be
  prepended to the element name separated by the namespace separator
  &quot;vertical bar&quot; (U+007C, <code>|</code>). (See, e.g., [[XML-NAMES]] for the use of namespaces in
  XML.)

  <p>The namespace component may be left empty (no prefix before the
  namespace separator) to indicate that the selector is only to
  represent elements with no namespace.

  <p>An asterisk may be used for the namespace prefix, indicating that
  the selector represents elements in any namespace (including elements
  with no namespace).

  <p>Element type selectors that have no namespace component (no
  namespace separator) represent elements without regard to the
  element's namespace (equivalent to "<code>*|</code>") unless a default
  namespace has been <a href="#nsdecl">declared</a>  for namespaced selectors (e.g. in CSS, in
  the style sheet). If a default namespace has been declared, such
  selectors will represent only elements in the default namespace.

  <p>A type selector containing a namespace prefix that has not been
  previously <a href="#nsdecl">declared</a> for namespaced selectors is
  an <a href="#conformance">invalid</a> selector.

  <p>In a namespace-aware client, the name part of element type
  selectors (the part after the namespace separator, if it is present)
  will only match against the <a
  href="http://www.w3.org/TR/REC-xml-names/#NT-LocalPart">local part</a>
  of the element's <a
  href="http://www.w3.org/TR/REC-xml-names/#ns-qualnames">qualified
  name</a>.

  <p>In summary:

  <dl>
    <dt><code>ns|E</code>
    <dd>elements with name E in namespace ns
    <dt><code>*|E</code>
    <dd>elements with name E in any namespace, including those without a
    namespace
    <dt><code>|E</code>
    <dd>elements with name E without a namespace
    <dt><code>E</code>
    <dd>if no default namespace has been <a href="#nsdecl">declared</a>  for selectors, this is
    equivalent to *|E.  Otherwise it is equivalent to ns|E where ns is
    the default namespace.
  </dl>

  <div class="example">
   <p>CSS examples:

   <pre>
   @namespace foo url(http://www.example.com);
   foo|h1 { color: blue }  /* first rule */
   foo|* { color: yellow } /* second rule */
   |h1 { color: red }      /* ...*/
   *|h1 { color: green }
   h1 { color: green }</pre>

   <p>The first rule (not counting the <code>@namespace</code> at-rule)
   will match only <code>h1</code> elements in the
   "http://www.example.com" namespace.

   <p>The second rule will match all elements in the
   "http://www.example.com" namespace.

   <p>The third rule will match only <code>h1</code> elements with
   no namespace.

   <p>The fourth rule will match <code>h1</code> elements in any
   namespace (including those without any namespace).

   <p>The last rule is equivalent to the fourth rule because no default
   namespace has been defined.

  </div>

<h3 id="universal-selector">
Universal selector </h3>

  <p>The <dfn>universal selector</dfn>, written as a
  <a href="http://www.w3.org/TR/css3-namespace/#css-qnames">CSS qualified
  name</a> [[!CSS3NAMESPACE]] with an asterisk (<code>*</code>
  U+002A) as the local name, represents the qualified name of any element
  type. It represents any single element in the document tree in any
  namespace (including those without a namespace) if no default
  namespace has been specified for selectors. If a default namespace has
  been specified, see <a href="#univnmsp">Universal selector and
  Namespaces</a> below.

  <p>If a universal selector represented by <code>*</code> (i.e. without a
  namespace prefix) is not the only component of a <i>compound selector</i>
  or is immediately followed by a <i>pseudo-element</i>, then the <code>*</code> may
  be omitted and the universal selector's presence implied.

  <div class="example">
   <p>Examples:
   <ul>
    <li><code>*[hreflang|=en]</code> and <code>[hreflang|=en]</code> are equivalent,
    <li><code>*.warning</code> and <code>.warning</code> are equivalent,
    <li><code>*#myid</code> and <code>#myid</code> are equivalent.
   </ul>
  </div>

  <p class="note"><strong>Note:</strong> it is recommended that the
  <code>*</code> not be omitted, because it decreases the potential
  confusion between, for example,
  <code style="white-space: nowrap">div :first-child</code>
  and <code style="white-space: nowrap">div:first-child</code>.
  Here, <code style="white-space: nowrap">div *:first-child</code>
  is more readable.

<h4 id="univnmsp">
Universal selector and namespaces</h4>

  <p>The universal selector allows an optional namespace component. It
  is used as follows:

  <dl>
   <dt><code>ns|*</code>
   <dd>all elements in namespace ns
   <dt><code>*|*</code>
   <dd>all elements
   <dt><code>|*</code>
   <dd>all elements without a namespace
   <dt><code>*</code>
   <dd>if no default namespace has been specified, this is equivalent to *|*.
   Otherwise it is equivalent to ns|* where ns is the default namespace.
  </dl>

  <p>A universal selector containing a namespace prefix
    that has not been previously <a href="#nsdecl">declared</a>
    is an <a href="#conformance">invalid</a> selector.


<h2 id="attribute-selectors">
Attribute selectors</h2>

  <p>Selectors allow the representation of an element's attributes. When
  a selector is used as an expression to match against an element,
  an <dfn>attribute selector</dfn> must be considered to match an element if that
  element has an attribute that matches the attribute represented by the
  attribute selector.

  <p class="issue">Add comma-separated syntax for
  <a href="http://lists.w3.org/Archives/Public/www-style/2011Mar/0215.html">multiple-value matching</a>?
  e.g. [rel ~= next, prev, up, first, last]

<h3 id="attribute-representation">
Attribute presence and value selectors</h3>

  <p>CSS2 introduced four attribute selectors:

  <dl>
    <dt><code>[att]</code>
    <dd>Represents an element with the <code>att</code> attribute, whatever the value of
    the attribute.
    <dt><code>[att=val]</code>
    <dd>Represents an element with the <code>att</code> attribute whose value is exactly
    "val".
    <dt><code>[att~=val]</code>
    <dd>Represents an element with the <code>att</code> attribute whose value is a <a
    href="#whitespace">whitespace</a>-separated list of words, one of
    which is exactly "val". If "val" contains whitespace, it will never
    represent anything (since the words are <em>separated</em> by
    spaces). Also if "val" is the empty string, it will never represent
    anything.
    <dt><code>[att|=val]</code>
    <dd>Represents an element with the <code>att</code> attribute, its
    value either being exactly "val" or beginning with "val" immediately
    followed by "-" (U+002D).  This is primarily intended to allow
    language subcode matches (e.g., the <code>hreflang</code> attribute
    on the <code>a</code> element in HTML) as described in BCP 47 ([[BCP47]]) or its successor.  For
    <code>lang</code> (or <code>xml:lang</code>) language subcode
    matching, please see <a href="#lang-pseudo">the <code>:lang</code>
    pseudo-class</a>.
  </dl>

  <p>Attribute values must be CSS <a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">identifiers</a>
  or <a href="http://www.w3.org/TR/CSS21/syndata.html#strings">strings</a>. [[!CSS21]]

  <div class="example">

    <p>Examples:

    <p>The following attribute selector represents an <code>h1</code>
    element that carries the <code>title</code> attribute, whatever its
    value:

    <pre>h1[title]</pre>

    <p>In the following example, the selector represents a
    <code>span</code> element whose <code>class</code> attribute has
    exactly the value "example":

    <pre>span[class="example"]</pre>

    <p>Multiple attribute selectors can be used to represent several
    attributes of an element, or several conditions on the same
    attribute. Here, the selector represents a <code>span</code> element
    whose <code>hello</code> attribute has exactly the value "Cleveland"
    and whose <code>goodbye</code> attribute has exactly the value
    "Columbus":

    <pre>span[hello="Cleveland"][goodbye="Columbus"]</pre>

    <p>The following CSS rules illustrate the differences between
    "=" and "~=".  The first selector would match, for example, an
    <code>a</code> element with the value "copyright copyleft
    copyeditor" on a <code>rel</code> attribute. The second selector
    would only match an <code>a</code> element with an <code>href</code>
    attribute having the exact value "http://www.w3.org/".

    <pre><!--
    -->a[rel~="copyright"] { ... }&#xa;<!--
    -->a[href="http://www.w3.org/"] { ... }</pre>

    <p>The following selector represents an <code>a</code> element
    whose <code>hreflang</code> attribute is exactly "fr".

    <pre>a[hreflang=fr]</pre>

    <p>The following selector represents an <code>a</code> element for
    which the value of the <code>hreflang</code> attribute begins with
    "en", including "en", "en-US", and "en-scouse":

    <pre>a[hreflang|="en"]</pre>

    <p>The following selectors represent a <code>DIALOGUE</code> element
    whenever it has one of two different values for an attribute
    <code>character</code>:

    <pre><!--
    -->DIALOGUE[character=romeo]&#xa;<!--
    -->DIALOGUE[character=juliet]</pre>

  </div>

<h3 id="attribute-substrings">
Substring matching attribute selectors</h3>

  <p>Three additional attribute selectors are provided for matching
  substrings in the value of an attribute:

  <dl>
    <dt><code>[att^=val]</code>
    <dd>Represents an element with the <code>att</code> attribute whose value begins
    with the prefix "val". If "val" is the empty string then the selector does not
    represent anything.
    <dt><code>[att$=val]</code>
    <dd>Represents an element with the <code>att</code> attribute whose value ends with
    the suffix "val". If "val" is the empty string then the selector does not represent
    anything.
    <dt><code>[att*=val]</code>
    <dd>Represents an element with the <code>att</code> attribute whose value contains
    at least one instance of the substring "val". If "val" is the empty string then
    the selector does not represent anything.
  </dl>

  <p>Attribute values must be CSS <a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">identifiers</a>
  or <a href="http://www.w3.org/TR/CSS21/syndata.html#strings">strings</a>. [[!CSS21]]

  <div class="example">
   <p>Examples:
   <p>The following selector represents an HTML <code>object</code>, referencing an
   image:
   <pre>object[type^="image/"]</pre>
   <p>The following selector represents an HTML anchor <code>a</code> with an
   <code>href</code> attribute whose value ends with ".html".
   <pre>a[href$=".html"]</pre>
   <p>The following selector represents an HTML paragraph with a <code>title</code>
   attribute whose value contains the substring "hello"
   <pre>p[title*="hello"]</pre>
  </div>

<h3 id="attribute-case">
Case-sensitivity</h3>

  <p>By default case-sensitivity of attribute names and values in selectors
  depends on the document language. To match attribute values case-insensitively
  regardless of document language rules, the attribute selector may include the
  identifier <code>i</code> before the closing bracket (<code>]</code>).
  When this flag is present, UAs must match the attribute's value
  case-insensitively within the ASCII range.

  <div class="example">
    <p>The following rule will style the <code>frame</code> attribute when it
      has a value of <code>hsides</code>, whether that value is represented
      as <code>hsides</code>, <code>HSIDES</code>, <code>hSides</code>, etc.
      even in an XML environment where attribute values are case-sensitive.
    <pre>[frame=hsides i] { border-style: solid none; }</pre>
  </div>

  <!-- plinss notes we may eventually want to choose other normalizations
       for attribute matching; but since there's no normalization scheme
       that really seems needed at this point, this issue is deferred to
       a later level -->

<h3 id="attrnmsp">
Attribute selectors and namespaces</h3>

  <p>The attribute name in an attribute selector is given as a
  <a href="http://www.w3.org/TR/css3-namespace/#css-qnames">CSS qualified
  name</a>: a namespace prefix that has been previously <a href="#nsdecl">declared</a>
  may be prepended to the attribute name separated by the namespace
  separator &quot;vertical bar&quot; (<code>|</code>). In keeping with
  the Namespaces in the XML recommendation, default namespaces do not
  apply to attributes, therefore attribute selectors without a namespace
  component apply only to attributes that have no namespace (equivalent
  to "<code>|attr</code>"). An asterisk may be used for
  the namespace prefix indicating that the selector is to match all
  attribute names without regard to the attribute's namespace.

  <p>An attribute selector with an attribute name containing a namespace
  prefix that has not been previously <a href="#nsdecl">declared</a> is
  an <a href="#conformance">invalid</a> selector.

  <div class="example">
    <p>CSS examples:
    <pre><!--
    -->@namespace foo "http://www.example.com";&#xa;<!--
    -->[foo|att=val] { color: blue }&#xa;<!--
    -->[*|att] { color: yellow }&#xa;<!--
    -->[|att] { color: green }&#xa;<!--
    -->[att] { color: green }</pre>

    <p>The first rule will match only elements with the attribute
    <code>att</code> in the "http://www.example.com" namespace with the
    value "val".

    <p>The second rule will match only elements with the attribute
    <code>att</code> regardless of the namespace of the attribute
    (including no namespace).

    <p>The last two rules are equivalent and will match only elements
    with the attribute <code>att</code> where the attribute is not
    in a namespace.

  </div>

<h3 id="def-values">
Default attribute values in DTDs</h3>

  <p>Attribute selectors represent attribute values in the document tree.
  How that document tree is constructed is outside the scope of Selectors.
  In some document formats default attribute values can be defined in a DTD or
  elsewhere, but these can only be selected by attribute selectors if they
  appear in the document tree. Selectors should be designed so that they
  work whether or not the default values are included in the document tree.

  <p>For example, a XML UA may, but is <em>not</em> required to,
  read an “external subset” of the DTD, but <em>is</em> required to
  look for default attribute values in the document's “internal subset”.
  (See, e.g., [[XML10]] for definitions of these subsets.)
  Depending on the UA, a default attribute value defined in the external subset of the DTD
  might or might not appear in the document tree.

  <p>A UA that recognizes an XML namespace may, but is not required to use its
  knowledge of that namespace to treat default attribute values as if
  they were present in the document. (For example, an XHTML UA is not
  required to use its built-in knowledge of the XHTML DTD. See, e.g., [[XML-NAMES]] for details on namespaces in XML
  1.0.)

  <p class="note"><strong>Note:</strong> Typically, implementations
  choose to ignore external subsets. This corresponds to the behaviour
  of non-validating processors as defined by the XML specification.

  <div class="example">
    <p>Example:

    <p>Consider an element <code>EXAMPLE</code> with an attribute <code>radix</code>
    that has a default value of <code>"decimal"</code>. The DTD fragment might be

    <pre class="dtd-example">&lt;!ATTLIST EXAMPLE radix (decimal,octal) "decimal"></pre>

    <p>If the style sheet contains the rules

    <pre><!--
    -->EXAMPLE[radix=decimal] { /*... default property settings ...*/ }&#xa;<!--
    -->EXAMPLE[radix=octal]   { /*... other settings...*/ }</pre>

    <p>the first rule might not match elements whose <code>radix</code> attribute is
    set by default, i.e. not set explicitly. To catch all cases, the
    attribute selector for the default value must be dropped:

    <pre><!--
    -->EXAMPLE                { /*... default property settings ...*/ }&#xa;<!--
    -->EXAMPLE[radix=octal]   { /*... other settings...*/ }</pre>

    <p>Here, because the selector <code>EXAMPLE[radix=octal]</code> is
    more specific than the type selector alone, the style declarations in
    the second rule will override those in the first for elements that
    have a <code>radix</code> attribute value of <code>"octal"</code>. Care has to be taken that
    all property declarations that are to apply only to the default case
    are overridden in the non-default cases' style rules.
  </div>

<h3 id="class-html">
Class selectors</h3>

  <p>The <dfn>class selector</dfn> is given as a full stop (. U+002E) immediately
  followed by an identifier. It represents an element belonging to the
  class identified by the identifier, as defined by the document language.
  For example, in [[HTML5]], [[SVG11]], and [[MATHML]] membership in a
  class is given by the <code>class</code> attribute: in these languages
  it is equivalent to the <code>~=</code> notation applied to the
  local <code>class</code> attribute
  (i.e. <code>[class~=<var>identifier</var>]</code>).

  <div class="example">
   <p>CSS examples:

   <p>We can assign style information to all elements with
   <code>class~="pastoral"</code> as follows:

    <pre>*.pastoral { color: green }  /* all elements with class~=pastoral */</pre>

    <p>or just

    <pre>.pastoral { color: green }  /* all elements with class~=pastoral */</pre>

    <p>The following assigns style only to H1 elements with
    <code>class~="pastoral"</code>:

    <pre>H1.pastoral { color: green }  /* H1 elements with class~=pastoral */</pre>

    <p>Given these rules, the first <code>H1</code> instance below would not have
    green text, while the second would:

    <pre>
  &lt;H1>Not green&lt;/H1>
  &lt;H1 class="pastoral">Very green&lt;/H1></pre>

    <p>The following rule matches any <code>P</code> element whose <code>class</code>
    attribute has been assigned a list of <a
    href="#whitespace">whitespace</a>-separated values that includes both
    <code>pastoral</code> and <code>marine</code>:

    <pre>p.pastoral.marine { color: green }</pre>

    <p>This rule matches when <code>class="pastoral blue aqua
    marine"</code> but does not match for <code>class="pastoral
    blue"</code>.

  </div>

  <p class="note"><strong>Note:</strong> Because CSS gives considerable
  power to the "class" attribute, authors could conceivably design their
  own "document language" based on elements with almost no associated
  presentation (such as <code>DIV</code> and <code>SPAN</code> in HTML)
  and assigning style
  information through the "class" attribute.  Authors should avoid this
  practice since the structural elements of a document language often
  have recognized and accepted meanings and author-defined classes may
  not.

  <p class="note"><strong>Note:</strong> If an element has multiple
  class attributes, their values must be concatenated with spaces
  between the values before searching for the class. As of this time the
  working group is not aware of any manner in which this situation can
  be reached, however, so this behavior is explicitly non-normative in
  this specification.

<h3 id="id-selectors">
ID selectors</h3>

  <p>Document languages may contain attributes that are declared to be of type ID.
    What makes attributes of type ID special
    is that no two such attributes can have the same value in a conformant document,
    regardless of the type of the elements that carry them;
    whatever the document language,
    an ID typed attribute can be used to uniquely identify its element.
    In HTML all ID attributes are named <code>id</code>;
    XML applications may name ID attributes differently,
    but the same restriction applies.
    Which attribute on an element is considered the “ID attribute“ is defined by the document language.

  <p>An <dfn>ID selector</dfn> consists of a “number sign” (U+0023, <code>#</code>)
    immediately followed by the ID value,
    which must be a CSS <a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">identifier</a>.
    An ID selector represents an element instance that has an identifier that matches the identifier in the ID selector.
    (It is possible in non-conforming documents for multiple elements to match a single ID selector.)

  <div class="example">
    <p>Examples:
    <p>The following ID selector represents an <code>h1</code> element
    whose ID-typed attribute has the value "chapter1":
    <pre>h1#chapter1</pre>
    <p>The following ID selector represents any element whose ID-typed
    attribute has the value "chapter1":
    <pre>#chapter1</pre>
    <p>The following selector represents any element whose ID-typed
    attribute has the value "z98y".
    <pre>*#z98y</pre>
  </div>

  <p class="note"><strong>Note:</strong> In XML 1.0 [[XML10]], the information about which attribute
  contains an element's IDs is contained in a DTD or a schema. When
  parsing XML, UAs do not always read the DTD, and thus may not know
  what the ID of an element is (though a UA may have namespace-specific
  knowledge that allows it to determine which attribute is the ID
  attribute for that namespace). If a style sheet author knows or
  suspects that a UA may not know what the ID of an element is, he
  should use normal attribute selectors instead:
  <code>[name=p371]</code> instead of <code>#p371</code>.

  <p>If an element has multiple ID attributes, all of them must be
  treated as IDs for that element for the purposes of the ID
  selector. Such a situation could be reached using mixtures of xml:id,
  DOM3 Core, XML DTDs, and namespace-specific knowledge.

<h2 id="linguistic-pseudos">
Linguistic Pseudo-classes</h2>

<h3 id="the-dir-pseudo">
The directionality pseudo-class <code>:dir()</code></h3>

  <p>The <dfn id='dir-pseudo'>:dir()</dfn> pseudo-class allows the author to write
  selectors that represent an element based on its directionality as
  determined by the document language.
  For example, [[HTML5]] defines <a href="http://www.whatwg.org/html/selectors.html#selector-ltr">how to determine the directionality of an element</a>,
  based on a combination of the <code>dir</code> attribute, the surrounding text, and other factors.
  The <code>:dir()</code> pseudo-class does not select based on stylistic
  states&#8212;for example, the CSS 'direction' property does not affect
  whether it matches.

  <p>The pseudo-class <code>:dir(ltr)</code> represents an element that
  has a directionality of left-to-right (<code>ltr</code>). The
  pseudo-class <code>:dir(rtl)</code> represents an element that has
  a directionality of right-to-left (<code>rtl</code>). The argument to
  <code>:dir()</code> must be a single identifier, otherwise the selector
  is invalid. White space is optionally allowed between the identifier
  and the parentheses. Values other than <code>ltr</code> and
  <code>rtl</code> are not invalid, but do not match anything. (If a
  future markup spec defines other directionalities, then Selectors may
  be extended to allow corresponding values.)

  <p>The difference between <code>:dir(C)</code> and <code>[dir=C]</code>
  is that <code>[dir=C]</code> only performs a comparison against a given
  attribute on the element, while the <code>:dir(C)</code> pseudo-class
  uses the UAs knowledge of the document's semantics to perform the
  comparison. For example, in HTML, the directionality of an element
  inherits so that a child without a <code>dir</code> attribute will have
  the same directionality as its closest ancestor with a valid <code>dir</code>
  attribute. As another example, in HTML,
  an element that matches <code>[dir=auto]</code> will match either
  <code>:dir(ltr)</code> or <code>:dir(rtl)</code> depending on the resolved
  directionality of the elements as determined by its contents. [[HTML5]]

<h3 id="the-lang-pseudo">
The language pseudo-class <code>:lang()</code></h3>

  <p>If the document language specifies how the (human) content language of an
  element is determined, it is possible to write selectors that
  represent an element based on its language.
  The <dfn id='lang-pseudo'>:lang()</dfn> pseudo-class represents an element that
  is in one of the languages listed in its argument. It accepts
  a comma-separated list of one or more <i>language ranges</i> as its
  argument. Each <dfn>language range</dfn> in <code>:lang()</code>
  must be a valid CSS <a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">identifier</a>
  [[!CSS21]]
  or consist of an asterisk (* U+002A) immediately followed by an identifier
  beginning with an ASCII hyphen (U+002D) for the selector to be valid.

  <p>The <dfn>language</dfn> of an element is defined by the document language.
  For example, in HTML [[HTML401]], the <i>language</i> is determined by a
  combination of the <code>lang</code> attribute, information from
  <code>meta</code> elements, and possibly also the protocol (e.g.
  from HTTP headers). XML languages can use the <code>xml:lang</code>
  attribute to indicate language information for an element.

  <p>The element's <i>language</i> matches a <i>language range</i> if
  the element's <i>language</i> (normalized to BCP 47 syntax if necessary)
  matches the given <i>language range</i> in an <i>extended filtering</i>
  operation per [[RFC4647]] <cite>Matching of Language Tags</cite> (section 3.3.2).
  The matching is performed case-insensitively within the ASCII range.
  The <i>language range</i> does not need to be a valid language code to
  perform this comparison.

  <p class="note"><strong>Note:</strong> It is recommended that
  documents and protocols indicate language using codes from BCP 47 [[BCP47]]
  or its successor, and by means of <code>xml:lang</code> attributes in the
  case of XML-based documents [[XML10]]. See <a
  href="http://www.w3.org/International/questions/qa-lang-2or3.html">
  "FAQ: Two-letter or three-letter language codes."</a>

  <div class="example">
    <p>Examples:
    <p>The two following selectors represent an HTML document that is in
    Belgian French or German. The two next selectors represent
    <code>q</code> quotations in an arbitrary element in Belgian French
    or German.
    <pre><!--
    -->html:lang(fr-be)&#xa;<!--
    -->html:lang(de)&#xa;<!--
    -->:lang(fr-be) > q&#xa;<!--
    -->:lang(de) > q</pre>
  </div>

  <p class="note">One difference between <code>:lang(C)</code> and the ''|='' operator
  is that the ''|='' operator only performs a comparison against a given
  attribute on the element, while the <code>:lang(C)</code> pseudo-class
  uses the UAs knowledge of the document's semantics to perform the
  comparison.

  <div class=example>

    <p>In this HTML example, only the BODY matches
    <code>[lang|=fr]</code> (because it has a LANG attribute) but both
    the BODY and the P match <code>:lang(fr)</code> (because both are in
    French). The P does not match the <code>[lang|=fr]</code> because it
    does not have a LANG attribute.
    <pre><!--
    -->&lt;body lang=fr>&#xa;<!--
    -->  &lt;p>Je suis français.&lt;/p>&#xa;<!--
    -->&lt;/body></pre>
  </div>

  <div class=example>
    <p>Another difference between <code>:lang(C)</code> and the ''|='' operator
    is that <code>:lang(C)</code> performs implicit wildcard matching.
    For example, <code>:lang(de-DE)</code> will match all of ''de-DE'',
    ''de-DE-1996'', ''de-Latn-DE'', ''de-Latf-DE'', ''de-Latn-DE-1996'',
    whereas of those <code>[lang|=de-DE]</code> will only match ''de-DE'' and
    ''de-DE-1996''.
    <p>To perform wildcard matching on the first subtag (the primary language),
    an asterisk must be used: <code>*-CH</code> will match all of ''de-CH'',
    ''it-CH'', ''fr-CH'', and ''rm-CH''.
    <p>Note that asterisks are not allowed anywhere else in <code>:lang()</code>'s
    language range syntax: they only have meaning, and are therefore only allowed,
    at the beginning.
  </div>

  <p class="note">Wildcard language matching is new in Level 4.


<h2 id="location">
Location Pseudo-classes</h2>

<h3 id="the-any-link-pseudo">
The hyperlink pseudo-class: <code>:any-link</code></h3>

  <p>The <dfn id='any-link-pseudo'>:any-link</dfn> pseudo-class represents an element
    that acts as the source anchor of a hyperlink.
    For example, in [[HTML5]], any <code>&lt;a></code>, <code>&lt;area></code>, or <code>&lt;link></code> elements with an <code>href</code> attribute
    are hyperlinks, and thus <a href="http://www.whatwg.org/html/selectors.html#selector-link">match <code>:any-link</code></a>.
    It matches an element if the element would match <code>:link</code> or <code>:visited</code>,
    equivalent to '':matches(:link, :visited)''.


  <p class="issue">Any better name suggestions for this pseudo?<p>

<h3 id="link">
The link history pseudo-classes: <code>:link</code> and <code>:visited</code></h3>

  <p>User agents commonly display unvisited <a href="#the-any-link-pseudo">hyperlinks</a> differently from
  previously visited ones. Selectors
  provides the pseudo-classes <dfn id='link-pseudo'>:link</dfn> and
  <dfn id='visited-pseudo'>:visited</dfn> to distinguish them:

  <ul>
    <li>The <code>:link</code> pseudo-class applies to links that have
    not yet been visited.
    <li>The <code>:visited</code> pseudo-class applies once the link has
    been visited by the user.
  </ul>

  <p>After some amount of time, user agents may choose to return a
  visited link to the (unvisited) ':link' state.

  <p>The two states are mutually exclusive.

  <div class="example">

    <p>Example:

    <p>The following selector represents links carrying class
    <code>footnote</code> and already visited:

    <pre>.footnote:visited</pre>

  </div>

  <p class="note"><strong>Note:</strong> It is possible for style sheet
  authors to abuse the :link and :visited pseudo-classes to determine
  which sites a user has visited without the user's consent.

  <p>UAs may therefore treat all links as unvisited links, or implement
  other measures to preserve the user's privacy while rendering visited
  and unvisited links differently.


<h3 id="local-pseudo">
The local link pseudo-class <code>:local-link</code></h3>

  <p>The <dfn id='local-link-pseudo'>:local-link</dfn> pseudo-class allows authors to style
    <a href="#the-any-link-pseudo">hyperlinks</a> based on the users current location within a site and to
    differentiate site-internal versus site-external links.

  <p>The (non-functional) <code>:local-link</code> pseudo-class represents an element that is
    the source anchor of a hyperlink whose target's absolute URL
    matches the element's own document URL.
    Any fragment identifiers are stripped before matching the document's URL against the link's URL;
    otherwise all portions of the URL are considered.

  <div class="example">
    <p>For example, the following rule prevents links targetting the
      current page from being underlined when they are part of the
      navigation list:
    <pre>nav :local-link { text-decoration: none; }</pre>
  </div>

  <p>As a functional pseudo-class, <code>:local-link()</code> can also accept a non-negative integer as its sole argument,
    which, if the document's URL belongs to a hierarchical scheme,
    indicates the number of path levels to match:
  <ul>
    <li>'':local-link(0)'' represents a link element whose target is in the same origin as the document's URL
    <li>'':local-link(1)'' represents a link element whose target has the same origin and first path segment
    <li>'':local-link(2)'' represents a link element whose target has the same origin, first, and second path segments
    <li>etc.
  </ul>

  <div class="example">
    <p>The following example styles all site-external links with a dashed
      underline.
    <pre>:not(:local-link(0)) { text-decoration-style: dashed; }</pre>
  </div>

  <p>Path segments are portions of the URL's path that are separated by forward slashes (/).
    If a segment is missing from the document's URL,
    a pseudo-class requiring that segment to match does not match anything.

  <div class="example">
    <p>So, given the links:
    <ol>
      <li><code>&lt;a href="http://www.example.com">Home&lt;/a></code>
      <li><code>&lt;a href="http://www.example.com/2011">2011&lt;/a></code>
      <li><code>&lt;a href="http://www.example.com/2011/03">March&lt;/a></code>
      <li><code>&lt;a href="http://www.example.com/2011/03/">March&lt;/a></code>
      <li><code>&lt;a href="http://www.example.com/2011/03/21">21 March&lt;/a></code>
      <li><code>&lt;a href="https://www.example.com/2011/03/">March&lt;/a></code>
      <li><code>&lt;a href="http://example.com/2011/03/">March&lt;/a></code>
    </ol>
    <p>and the styles:
    <ol type=A>
       <li><code>a:local-link {...}</code>
       <li><code>a:local-link(0) {...}</code>
       <li><code>a:local-link(1) {...}</code>
       <li><code>a:local-link(2) {...}</code>
       <li><code>a:local-link(3) {...}</code>
       <li><code>a:local-link(4) {...}</code>
    </ol>
    <p>If the document's URL is <code>http://www.example.com/2011/03/</code>:
    <ol>
      <li>Link 1 would receive Style B
      <li>Link 2 would receive Styles B and C
      <li>Link 3 would receive Styles B, C, and D
      <li>Link 4 would also receive Styles A, B, C, D, and E
      <li>Link 5 would receive Styles B, C, and D
      <li>Link 6 would remain unstyled
      <li>Link 7 would remain unstyled
      <li>Style F would not be applied to anything
    </ol>
  </div>

  <p>
    The "origin" of the URL is defined by <a href="http://tools.ietf.org/html/rfc6454#section-4">RFC 6454, Section 4</a>.
    The username, password, query string, and fragment portions of the URL are not considered
    when matching against <code>:local-link(<var>n</var>)</code>.
    If the document's URL does not belong to a hierarchical scheme,
    the functional pseudo-class matches nothing.

  <p class="issue">
    It's clear that, if the document URL has at least N segments,
    then <code>:local-link(N)</code> only matches links whose URL has at least N segments.
    (This lets you assign consistent semantics to :local-link so that,
    for example, :local-link(2) means a "within-repo" link on GitHub.)
    What about if the document url has less than N segments,
    and the link is same-page?
    Should "null segments" count as matching, or not?


<h3 id="the-target-pseudo">
The target pseudo-class <code>:target</code></h3>

  <p>Some URLs refer to a location within a resource. This kind of URL
  ends with a &quot;number sign&quot; (#) followed by an anchor
  identifier (called the fragment identifier).

  <p>URLs with fragment identifiers link to a certain element within the
  document, known as the target element. For instance, here is a URL
  pointing to an anchor named <code>section_2</code> in an HTML
  document:

  <pre>http://example.com/html/top.html#section_2</pre>

  <p>The <dfn id='target-pseudo'>:target</dfn> pseudo-class matches the target element of the document's URL.
    If the document's URL has no fragment identifier, then the document has no target element.

  <div class="example">
    <p>Example:
    <pre>p.note:target</pre>
    <p>This selector represents a <code>p</code> element of class
    <code>note</code> that is the target element of the referring
    URL.
  </div>

  <div class="example">
    <p>CSS example:
    <p>Here, the <code>:target</code> pseudo-class is used to make the
    target element red and place an image before it, if there is one:
    <pre><!--
    -->*:target { color : red }&#xa;<!--
    -->*:target::before { content : url(target.png) }</pre>
  </div>


<h3 id="the-scope-pseudo">
The reference element pseudo-class <code>:scope</code></h3>

  <p>
    The <dfn id='scope-pseudo'>:scope</dfn> pseudo-class represents any element that is in
    the <dfn>reference element set</dfn>.
    This is is a (potentially empty) set of elements
    that provide a reference point for selectors to match against,
    such as that specified by the <code>querySelector()</code> call in [[SELECTORS-API2]],
    or the parent element of a <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/semantics.html#the-style-element">scoped <code>&lt;style></code> element</a> in [[HTML5]].

  <p>
    If the <i>reference element set</i> is not explicitly specified,
    it defaults to representing the <i>scoping root</i> (if any),
    else represents the root of the document (i.e. matches <code>:root</code>).
    Specifications intending for this pseudo-class to match specific elements
    rather than the document's root element
    must define either a <i>scoping root</i> (if using <i>scoped selectors</i>) or an explicit <i>reference element set</i>.

  <p class="note">
    Note that since this pseudo-class only represents elements,
    a virtual <i>scoping root</i> cannot be the subject of a selector;
    such a selector effectively represents nothing.

<h2 id="useraction-pseudos">
User Action Pseudo-classes</h2>

  <p>Interactive user agents sometimes change the rendering in response to user actions.
    Selectors provides three pseudo-classes for the selection of an element the user is acting on.
    (In non-interactive user agents, these pseudo-classes are valid, but never match any element.)

  <p>These pseudo-classes are not mutually exclusive. An element may
  match several pseudo-classes at the same time.

  <div class="example">
    <p>Examples:
    <pre><!--
    -->a:link    /* unvisited links */&#xa;<!--
    -->a:visited /* visited links */&#xa;<!--
    -->a:hover   /* user hovers */&#xa;<!--
    -->a:active  /* active links */</pre>
    <p>An example of combining dynamic pseudo-classes:
    <pre><!--
    -->a:focus&#xa;<!--
    -->a:focus:hover</pre>
    <p>The last selector matches <code>a</code> elements that are in
    the pseudo-class :focus and in the pseudo-class :hover.
  </div>

<h3 id="the-hover-pseudo">
The pointer hover pseudo-class <code>:hover</code></h3>

  <p>The <dfn id='hover-pseudo'>:hover</dfn> pseudo-class applies
    while the user designates an element with a pointing device,
    but does not necessarily activate it.
    For example, a visual user agent could apply this pseudo-class
    when the cursor (mouse pointer) hovers over a box generated by the element.
    Interactive user agents that cannot detect hovering due to hardware limitations
    (e.g., a pen device that does not detect hovering)
    are still conforming.

  <p>The parent of an element that is <code>:hover</code> is also in that state.

  <p>Host languages may define additional ways in which an element can match <code>:hover</code>.
    For example, [[HTML5]] defines a <code>&lt;label></code> element as <a href="http://www.whatwg.org/html/selectors.html#selector-hover">matching <code>:hover</code></a>
    when its labelled control is hovered.

  <p class="note"><strong>Note:</strong> Since the ':hover' state can apply to
  an element because its child is designated by a pointing device, then it is
  possible for ':hover' to apply to an element that is not underneath
  the pointing device.

  <p>The <code>:hover</code> pseudo-class can apply to any pseudo-element.

<h3 id="the-active-pseudo">
The activation pseudo-class <code>:active</code></h3>

  <p>The <dfn id='active-pseudo'>:active</dfn> pseudo-class applies while an element
    is being activated by the user. For example, between the times the
    user presses the mouse button and releases it. On systems with more
    than one mouse button, <code>:active</code> applies only to the
    primary or primary activation button (typically the "left" mouse
    button), and any aliases thereof.

  <p>There may be document language or implementation specific limits on
  which elements can become <code>:active</code>.
  For example, [[HTML5]] defines a <a href="http://www.whatwg.org/html/selectors.html#selector-active">list of activatable elements</a>.

  <p>Selectors doesn't define if the parent of an element that is
  ':active' is also in that state.

  <p class="note"><strong>Note:</strong> An element can be both
  ':visited' and ':active' (or ':link' and ':active').

<h3 id="the-focus-pseudo">
The input focus pseudo-class <code>:focus</code></h3>

  <p>The <dfn id='focus-pseudo'>:focus</dfn> pseudo-class applies while an element
    has the focus (accepts keyboard or mouse events, or other forms of
    input).

  <p>There may be document language or implementation specific limits on
  which elements can acquire <code>:focus</code>.
  For example, [[HTML5]] defines a <a href="http://www.whatwg.org/html/selectors.html#selector-active">list of activatable elements</a>.

<h3 id="drag-pseudos">
The drag-and-drop pseudo-class <code>:drop</code> and <code>:drop()</code></h3>

  <p>
    The <dfn>:drop</dfn> pseudo-class applies to all elements
    that are drop targets,
    as defined by the host language,
    while the user is “dragging”
    or otherwise conceptually carrying an item
    to be “dropped”.
    For example, in HTML the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#the-dropzone-attribute"><code>dropzone</code></a> attribute
    specified that an element is a drop target.

  <p>
    The <dfn>:drop()</dfn> functional pseudo-class is identical to '':drop'',
    but allows additional filters to be specified that can exclude some drop targets.
    Its syntax is:

  <pre class='prod'>:drop( [ active || valid || invalid ]? )</pre>

  <p>
    The keywords have the following meanings:

  <dl>
    <dt><dfn>active</dfn>
    <dd>
      The drop target is the current drop target for the drag operation.
      That is, if the user were to release the drag,
      it would be dropped onto this drop target.

    <dt><dfn>valid</dfn>
    <dd>
      If the host language has a concept of “valid” and “invalid” drop targets,
      this only matches if the drop target is valid for the object currently being dragged.
      Otherwise, it matches all drop targets.

      <p>
        For example, HTML's <code>dropzone</code> attribute can specify that the drop target only accepts strings or files that are set to a given type.

    <dt><dfn>invalid</dfn>
    <dd>
      If the host language has a concept of “valid” and “invalid” drop targets,
      this only matches if the drop target is invalid for the object currently being dragged.
      Otherwise, it matches nothing.
  </dl>

  <p>
    Multiple keywords can be combined in the argument,
    representing only drop targets that satisfy all of the keywords.
    For example, '':drop(valid active)'' will match the active drop target <em>if</em> it's valid,
    but not if it's invalid.

  <p>
    If no keywords are given in the argument,
    '':drop()'' has the same meaning as '':drop''
    - it matches every drop target.

<h2 id="time-pseudos">
Time-dimensional Pseudo-classes</h2>

  <p>These pseudo-classes classify elements with respect to the
    currently-displayed or active position in some timeline, such as
    during speech rendering of a document, or during the display of
    a video using WebVTT to render subtitles.

  <p>
    CSS does not define this timeline;
    the host language must do so.
    If there is no timeline defined for an element,
    these pseudo-classes must not match the element.

<h3 id="the-current-pseudo">
The current-element pseudo-class <code>:current</code></h3>

  <p>The <dfn id='current-pseudo'>:current</dfn> pseudo-class represents the
    element, or an ancestor of the element, that is currently being displayed.

  <p>Its alternate form <code>:current()</code>, like <code>:matches()</code>,
    takes a list of <i>compound selectors</i> as its argument: it represents the
    <code>:current</code> element that matches the argument or, if that does
    not match, the innermost ancestor of the <code>:current</code> element
    that does. (If neither the <code>:current</code> element nor its ancestors
    match the argument, then the selector does not represent anything.)

  <div class="example">
    <p>For example, the following rule will highlight whichever paragraph
    or list item is being read aloud in a speech rendering of the document:
    <pre><!--
    -->:current(p, li, dt, dd) {&#xa;<!--
    -->  background: yellow;&#xa;<!--
    -->}</pre>
  </div>

<h3 id="the-past-pseudo">
The past-element pseudo-class <code>:past</code></h3>

  <p>The <code>:past</code> pseudo-class represents any element that is
    defined to occur entirely prior to a <code>:current</code> element.
    For example, the WebVTT spec defines the <code>:past</code> pseudo-class <a href="http://dev.w3.org/html5/webvtt/#the-past-and-future-pseudo-classes">relative to the current playback position of a media element</a>.
    If a time-based order of elements is not defined by the document language,
    then this represents any element that is a (possibly indirect) previous
    sibling of a <code>:current</code> element.

<h3 id="the-future-pseudo">
The future-element pseudo-class <code>:future</code></h3>

  <p>The <dfn id='future-pseudo'>:future</dfn> pseudo-class represents any element that is
    defined to occur entirely after a <code>:current</code> element.
    For example, the WebVTT spec defines the <code>:future</code> pseudo-class <a href="http://dev.w3.org/html5/webvtt/#the-past-and-future-pseudo-classes">relative to the current playback position of a media element</a>.
    If a time-based order of elements is not defined by the document language,
    then this represents any element that is a (possibly indirect) next
    sibling of a <code>:current</code> element.


<h2 id='input-pseudos'>
The Input Pseudo-classes</h2>

  <p>
    The pseudo-classes in this section mostly apply to elements that take user input,
    such as HTML's <code>&lt;input></code> element.

<h3 id="input-states">
Input Control States</h3>

<h4 id="enableddisabled">
The <code>:enabled</code> and <code>:disabled</code> pseudo-classes</h4>

  <p>The <dfn id='enabled-pseudo'>:enabled</dfn> pseudo-class represents user interface elements
  that are in an enabled state; such elements have a corresponding disabled
  state.

  <p>Conversely, the <dfn id='disabled-pseudo'>:disabled</dfn> pseudo-class represents user
  interface elements that are in a disabled state; such elements have a
  corresponding enabled state.

  <p>What constitutes an enabled state, a disabled state, and a user interface
  element is host-language-dependent. In a typical document most elements will be
  neither <code>:enabled</code> nor <code>:disabled</code>.
  For example, [[HTML5]] defines <a href="http://www.whatwg.org/html/selectors.html#selector-enabled">non-disabled interactive elements to be <code>:enabled</code></a>,
  and any such elements that are <a href="http://www.whatwg.org/html/selectors.html#selector-disabled">explicitly disabled to be <code>:disabled</code></a>.

  <p class="note"><strong>Note:</strong> CSS properties that might affect a user’s ability
  to interact with a given user interface element do not affect whether it
  matches <code>:enabled</code> or <code>:disabled</code>; e.g., the
  <code>display</code> and <code>visibility</code> properties have no effect
  on the enabled/disabled state of an element.

<h4 id="rw-pseudos">
The mutability pseudo-classes <code>:read-only</code> and <code>:read-write</code></h4>

  <p>An element matches <dfn id="read-write-pseudo">:read-write</dfn> if it is user-alterable,
    as defined by the host language.
    Otherwise, it is <dfn id="read-only-pseudo">:read-only</dfn>.

  <p>For example, in [[HTML5]] a <a href="http://www.whatwg.org/html/selectors.html#selector-read-only">non-disabled non-readonly <code>&lt;input></code> element is <code>:read-write</code></a>,
    as is any element with the <code>contenteditable</code> attribute set to the true state.

<h4 id="placeholder">
The placeholder-shown pseudo-class <code>:placeholder-shown</code></h4>

  <p>Input elements can sometimes show placeholder text
  as a hint to the user on what to type in.
  See, for example, the <code>placeholder</code> attribute in [[HTML5]].
  The <dfn id="placeholder-shown-pseudo">:placeholder-shown</dfn> pseudo-class
  matches an input element that is showing such placeholder text.

<h4 id="the-default-pseudo">
The default-option pseudo-class <code>:default</code></h4>
  <p>The <dfn id='default-pseudo'>:default</dfn> pseudo-class applies to the one or more UI elements
  that are the default among a set of similar elements.  Typically applies to
  context menu items, buttons and select lists/menus.

  <p>One example is the default submit button among a set of buttons.
  Another example is the default option from a popup menu.
  In a select-many group (such as for pizza toppings), multiple elements can match <code>:default</code>.
  For example, [[HTML5]] defines that <a href="http://www.whatwg.org/html/selectors.html#selector-default"><code>:default</code> matches
  the “default button” in a form,
  the initially-selected <code>&lt;option></code>(s) in a <code>&lt;select></code>,
  and a few other elements.</a>

<h3 id="input-value-states">
Input Value States</h3>

<h4 id="checked">
The selected-option pseudo-class <code>:checked</code></h4>

  <p>Radio and checkbox elements can be toggled by the user. Some menu
  items are "checked" when the user selects them. When such elements are
  toggled "on" the <dfn id='checked-pseudo'>:checked</dfn> pseudo-class applies.
  For example, [[HTML5]] defines that <a href="http://www.whatwg.org/html/selectors.html#selector-checked">checked checkboxes, radio buttons, and selected <code>&lt;option></code> elements match <code>:checked</code></a>.


  <p>While the <code>:checked</code> pseudo-class is dynamic in nature,
  and can altered by user action,
  since it can also be based on the presence of semantic attributes in the document
  (such as the <code>selected</code> and <code>checked</code> attributes in [[HTML5]]),
  it applies to all media.

  <div class="example">
    <p>An unchecked checkbox can be selected by using the negation
    pseudo-class:
    <pre>:not(:checked)</pre>
  </div>

<h4 id="indeterminate">
The indeterminate-value pseudo-class <code>:indeterminate</code></h4>

  <p>The <dfn id='indetermine-pseudo'>:indeterminate</dfn> pseudo-class applies to UI elements whose
  value is in an indeterminate state.
  For example, radio and checkbox elements can be toggled between checked and unchecked states,
  but are sometimes in an indeterminate state, neither checked nor unchecked.
  Similarly a progress meter can be in an indeterminate state when the percent completion is unknown.
  For example, [[HTML5]] defines how <a href="http://www.whatwg.org/html/selectors.html#selector-indeterminate">checkboxes can be made to match <code>:indeterminate</code></a>.

  <p>Like the <code>:checked</code> pseudo-class, <code>:indeterminate</code>
  applies to all media. Components of a radio-group initialized with no
  pre-selected choice, for example, would be <code>:indeterminate</code>
  even in a static display.

<h3 id='ui-validity'>
Input Value-checking</h3>

<h4 id="validity-pseudos">
The validity pseudo-classes: <code>:valid</code> and <code>:invalid</code></h4>

  <p>
    An element is <dfn id="valid-pseudo">:valid</dfn>
    or <dfn id="invalid-pseudo">:invalid</dfn>
    when its contents or value is, respectively,
    valid or invalid with respect to data validity semantics defined by the document language
    (e.g. [[XFORMS11]] or [[HTML5]]).
    An element which lacks data validity semantics is neither <code>:valid</code> nor <code>:invalid</code>.

  <p class="note">
    Note that there is a difference between an element which has no constraints,
    and thus would always be <code>:valid</code>,
    and one which has no data validity semantics at all,
    and thus is neither <code>:valid</code> nor <code>:invalid</code>.
    In HTML, for example, an <code>&lt;input type="text"></code> element may have no constraints,
    but a <code>&lt;p></code> element has no validity semantics at all,
    and so it never matches either of these pseudo-classes.

<h4 id="range-pseudos">
The range pseudo-classes <code>:in-range</code> and <code>:out-of-range</code></h4>

  <p>The <dfn id="in-range-pseudo">:in-range</dfn> and
  <dfn id="out-of-range-pseudo">:out-of-range</dfn> pseudo-classes
  apply only to elements that have range limitations.  An element is
  <code>:in-range</code> or <code>:out-of-range</code> when the value
  that the element is bound to is in range or out of range with respect
  to its range limits as defined by the document language. An element
  that lacks data range limits or is not a form control is neither
  <code>:in-range</code> nor <code>:out-of-range</code>.
  E.g. a slider element with a value of 11 presented as a slider control
  that only represents the values from 1-10 is :out-of-range.  Another
  example is a menu element with a value of "E" that happens to be
  presented in a popup menu that only has choices "A", "B" and "C".

<h4 id="opt-pseudos">
The optionality pseudo-classes <code>:required</code> and <code>:optional</code></h4>

  <p>A form element is <dfn id="required-pseudo">:required</dfn> or
  <dfn id="optional-pseudo">:optional</dfn>
  if a value for it is, respectively, required or optional before the
  form it belongs to can be validly submitted. Elements that are not
  form elements are neither required nor optional.

<h4 id="user-pseudos">
The user-interaction pseudo-class <code>:user-error</code></h4>

  <p>
    The <dfn id="user-error-pseudo">:user-error</dfn> pseudo-class
    represents an input element with incorrect input, but only
    <em>after</em> the user has significantly interacted with it.
    The <code>:user-error</code> pseudo-class
    must match an <code>:invalid</code>, <code>:out-of-range</code>, or empty-but-<code>:required</code> form element
    between the time the user has attempted to submit the form
    and before the user has interacted again with the form element.
    User-agents may allow it to match such elements at other times,
    as would be appropriate for highlighting an error to the user.
    For example, a UA may choose to have <code>:user-error</code> match
    an <code>:invalid</code> element once the user has typed some text into it
    and changed the focus to another element,
    and to stop matching only after the user has successfully corrected the input.

  <div class='example'>
    <p>
      For example, the input in the following document fragment
      would match <code>:invalid</code> as soon as the page is loaded
      (because it the initial value violates the max-constraint),
      but it won't match <code>:user-error</code> until the user significantly interacts with the element,
      or attempts to submit the form it's part of.

    <pre><!--
    -->&lt;form>&#xa;<!--
    -->  &lt;label>&#xa;<!--
    -->    Volume:&#xa;<!--
    -->    &lt;input name='vol' type=number min=0 max=10 value=11>&#xa;<!--
    -->  &lt;/label>&#xa;<!--
    -->  ...&#xa;<!--
    -->&lt;/form></pre>
  </div>

<!--
  <p class="issue">
    If it's necessary to distinguish between omitted and invalid values,
    <code>:user-invalid</code> and <code>:user-omitted</code> could be used.
-->

<h2 id="structural-pseudos">
Tree-Structural pseudo-classes</h2>

  <p>Selectors introduces the concept of <dfn>structural
  pseudo-classes</dfn> to permit selection based on extra information that lies in
  the document tree but cannot be represented by other simple selectors or
  combinators.

  <p>Standalone text and other non-element
  nodes are not counted when calculating the position of an element in the list
  of children of its parent. When calculating the position of an element in
  the list of children of its parent, the index numbering starts at 1.


<h3 id="the-root-pseudo">
<code>:root</code> pseudo-class</h3>

  <p>The <dfn id='roo-pseudo'>:root</dfn> pseudo-class represents an element that is
  the root of the document. In HTML 4, this is always the
  <code>HTML</code> element.

<h3 id="the-empty-pseudo">
<code>:empty</code> pseudo-class</h3>

  <p>The <dfn id='empty-pseudo'>:empty</dfn> pseudo-class represents an element that has
  no children at all. In terms of the document tree, only element nodes and
  content nodes (such as DOM [[DOM-LEVEL-3-CORE]] text nodes, CDATA
  nodes, and entity references) whose data has a non-zero length must be
  considered as affecting emptiness;
  comments, processing instructions, and other nodes must not affect whether
  an element is considered empty or not.

  <div class="example">
   <p>Examples:
   <p><code>p:empty</code> is a valid representation of the following fragment:
   <pre>&lt;p>&lt;/p></pre>
   <p><code>foo:empty</code> is not a valid representation for the
   following fragments:
   <pre>&lt;foo>bar&lt;/foo></pre>
   <pre>&lt;foo>&lt;bar>bla&lt;/bar>&lt;/foo></pre>
   <pre>&lt;foo>this is not &lt;bar>:empty&lt;/bar>&lt;/foo></pre>
  </div>

<h3 id='the-blank-pseudo'>
<code>:blank</code> pseudo-class</h3>

  <p>The <dfn id='blank-pseudo'>:blank</dfn> pseudo-class is like the <code>:empty</code> pseudo-class,
    except that it additionally matches elements that only contain
    <a href="http://www.w3.org/TR/css3-text/#white-space-rules">code points affected by whitespace processing</a>. [[!CSS3TEXT]]

  <div class='example'>
    <p>For example, the following element matches <code>:blank</code>,
      but not <code>:empty</code>,
      because it contains at least one linebreak, and possibly other whitespace:

    <pre>&lt;p><br>&lt;/p></pre>
  </div>


<h3 id='child-index'>
Child-indexed Pseudo-classes</h3>

  <p>
    The pseudo-classes defined in this section select elements
    based on their index in their list of siblings.

<h4 id="the-nth-child-pseudo">
<code>:nth-child()</code> pseudo-class</h4>

  <p>The <dfn id='nth-child-pseudo' title=":nth-child()">:nth-child(<var>An+B</var>)</dfn>
    pseudo-class notation represents an element that has <var>An+B</var>-1 siblings
    <em>before</em> it in the document tree.
    The CSS Syntax Module [[!CSS3SYN]] defines the <a href="http://dev.w3.org/csswg/css-syntax/#anb"><var>An+B</var> notation</a>.

  <p>For example, this selector could address every other row in a table,
    and could be used to alternate the color of paragraph text in a cycle of four.

  <div class="example">
    <p>Examples:
    <pre><!--
    -->:nth-child(10n-1)  /* represents the 9th, 19th, 29th, etc, element */&#xa;<!--
    -->:nth-child(10n+9)  /* Same */&#xa;<!--
    -->:nth-child(10n+-1) /* Syntactically invalid, and would be ignored */</pre>
  </div>

<h4 id="the-nth-last-child-pseudo">
<code>:nth-last-child()</code> pseudo-class</h4>

  <p>The <dfn id='nth-last-child-pseudo' title=":nth-last-child()">:nth-last-child(<var>An+B</var>)</dfn>
    pseudo-class notation represents an element that has <var>An+B</var>-1 siblings
    <em>after</em> it in the document tree.
    The CSS Syntax Module [[!CSS3SYN]] defines the <a href="http://dev.w3.org/csswg/css-syntax/#anb"><var>An+B</var> notation</a>.


  <div class="example">
    <p>Examples:
    <pre><!--
    -->tr:nth-last-child(-n+2)    /* represents the two last rows of an HTML table */&#xa;<!--
    -->&#xa;<!--
    -->foo:nth-last-child(odd)    /* represents all odd foo elements in their parent element,&#xa;<!--
    -->                              counting from the last one */</pre>
  </div>

<h4 id="the-first-child-pseudo">
<code>:first-child</code> pseudo-class</h4>

  <p>The <dfn id='first-child-pseudo'>:first-child</dfn> pseudo-class
    represents an element that precedes all of its siblings (if any).
    Same as '':nth-child(1)''.

  <div class="example">
    <p>Examples:
    <p>The following selector represents a <code>p</code> element that is
    the first child of a <code>div</code> element:
    <pre>div > p:first-child</pre>
    <p>This selector can represent the <code>p</code> inside the
    <code>div</code> of the following fragment:
    <pre><!--
    -->&lt;p> The last P before the note.&lt;/p>&#xa;<!--
    -->&lt;div class="note">&#xa;<!--
       -->&lt;p> The first P inside the note.&lt;/p>&#xa;<!--
    -->&lt;/div></pre>
    but cannot represent the second <code>p</code> in the following fragment:
    <pre><!--
    -->&lt;p> The last P before the note.&lt;/p>&#xa;<!--
    -->&lt;div class="note">&#xa;<!--
       -->&lt;h2> Note &lt;/h2>&#xa;<!--
       -->&lt;p> The first P inside the note.&lt;/p>&#xa;<!--
    -->&lt;/div></pre>
    <p>The following two selectors are usually equivalent:
    <pre><!--
    -->* > a:first-child /* a is first child of any element */&#xa;<!--
    -->a:first-child /* Same (assuming a is not the root element) */</pre>
  </div>

<h4 id="the-last-child-pseudo">
<code>:last-child</code> pseudo-class</h4>

  <p>The <dfn id='last-child-pseudo'>:last-child</dfn> pseudo-class
    represents an element that follows all of its siblings (if any).
    Same as '':nth-last-child(1)''.

  <div class="example">
   <p>Example:
   <p>The following selector represents a list item <code>li</code> that
   is the last child of an ordered list <code>ol</code>.
   <pre>ol > li:last-child</pre>
  </div>

<h4 id="the-only-child-pseudo">
<code>:only-child</code> pseudo-class</h4>

  <p>The <dfn id='only-child-pseudo'>:only-child</dfn> pseudo-class
  represents an element that has no siblings.
  Same as '':first-child:last-child''
  or '':nth-child(1):nth-last-child(1)'',
  but with a lower specificity.


<h3 id='typed-child-index'>
Typed Child-indexed Pseudo-classes</h3>

  <p>
    The pseudo-elements in this section are similar to the <a href="#child-index">Child Index Pseudo-classes</a>,
    but they resolve based on an element's index <strong>among elements of the same <a href="#type-selectors">type (tag name)</a></strong> in their sibling list.

<h4 id="the-nth-of-type-pseudo">
<code>:nth-of-type()</code> pseudo-class</h4>

  <p>The <dfn id='nth-of-type-pseudo' title=":nth-of-type()">:nth-of-type(<var>An+B</var>)</dfn> pseudo-class notation
    represents an element that has <var>An+B</var>-1 siblings
    with the same <a href="http://www.w3.org/TR/css3-namespace/#expanded-name">expanded element name</a>
    <em>before</em> it in the document tree.
    The CSS Syntax Module [[!CSS3SYN]] defines the <a href="http://dev.w3.org/csswg/css-syntax/#anb"><var>An+B</var> notation</a>.


  <div class="example">
    <p>CSS example:
    <p>This allows an author to alternate the position of floated images:
    <pre><!--
    -->img:nth-of-type(2n+1) { float: right; }&#xa;<!--
    -->img:nth-of-type(2n) { float: left; }</pre>
  </div>


<h4 id="the-nth-last-of-type-pseudo">
<code>:nth-last-of-type()</code> pseudo-class</h4>

  <p>The <dfn id='nth-last-of-type' title=":nth-last-of-type()">:nth-last-of-type(<var>An+B</var>)</dfn> pseudo-class notation
    represents an element that has <var>An+B</var>-1 siblings
    with the same <a href="http://www.w3.org/TR/css3-namespace/#expanded-name">expanded element name</a>
    <em>after</em> it in the document tree.
    The CSS Syntax Module [[!CSS3SYN]] defines the <a href="http://dev.w3.org/csswg/css-syntax/#anb"><var>An+B</var> notation</a>.


  <div class="example">
    <p>Example:
    <p>To represent all <code>h2</code> children of an XHTML
    <code>body</code> except the first and last, one could use the
    following selector:
    <pre>body > h2:nth-of-type(n+2):nth-last-of-type(n+2)</pre>
    <p>In this case, one could also use <code>:not()</code>, although the
    selector ends up being just as long:
    <pre>body > h2:not(:first-of-type):not(:last-of-type)</pre>
  </div>

<h4 id="the-first-of-type-pseudo">
<code>:first-of-type</code> pseudo-class</h4>

  <p>The <dfn id='first-of-type-pseudo'>:first-of-type</dfn> pseudo-class
    represents an element that is the first sibling
    with the same <a href="http://www.w3.org/TR/css3-namespace/#expanded-name">expanded element name</a>
    in its sibling list.
    Same as '':nth-of-type(1)''.

  <div class="example">
    <p>Example:
    <p>The following selector represents a definition title
    <code>dt</code> inside a definition list <code>dl</code>, this
    <code>dt</code> being the first of its type in the list of children of
    its parent element.
    <pre>dl dt:first-of-type</pre>
    <p>It is a valid description for the first two <code>dt</code>
    elements in the following example but not for the third one:
    <pre><!--
    -->&lt;dl>&#xa;<!--
    -->  &lt;dt>gigogne&lt;/dt>&#xa;<!--
    -->  &lt;dd>&#xa;<!--
    -->    &lt;dl>&#xa;<!--
    -->      &lt;dt>fus&eacute;e&lt;/dt>&#xa;<!--
    -->      &lt;dd>multistage rocket&lt;/dd>&#xa;<!--
    -->      &lt;dt>table&lt;/dt>&#xa;<!--
    -->      &lt;dd>nest of tables&lt;/dd>&#xa;<!--
    -->    &lt;/dl>&#xa;<!--
    -->  &lt;/dd>&#xa;<!--
    -->&lt;/dl></pre>
  </div>

<h4 id="the-last-of-type-pseudo">
<code>:last-of-type</code> pseudo-class</h4>

  <p>The <dfn id='last-of-type-pseudo'>:last-of-type</dfn> pseudo-class
    represents an element that is the last sibling
    with the same <a href="http://www.w3.org/TR/css3-namespace/#expanded-name">expanded element name</a>
    in its sibling list.
    Same as '':nth-last-of-type(1)''.

  <div class="example">
    <p>Example:
    <p>The following selector represents the last data cell
    <code>td</code> of a table row <code>tr</code>.
    <pre>tr > td:last-of-type</pre>
  </div>

<h4 id="the-only-of-type-pseudo">
<code>:only-of-type</code> pseudo-class</h4>

  <p>The <dfn id='only-of-type-pseudo'>:only-of-type</dfn> pseudo-class
    represents an element that has no siblings
    with the same <a href="http://www.w3.org/TR/css3-namespace/#expanded-name">expanded element name</a>.
    Same as '':first-of-type:last-of-type''
    or '':nth-of-type(1):nth-last-of-type(1)'',
    but with a lower specificity.


<h3 id="selected-child-index">
Selected Child-indexed Pseudo-classes</h3>

  <p>
    The pseudo-classes in this section are also similar to <a href="#child-index">Child Index Pseudo-classes</a>,
    but they resolve based on an element's index in the set of siblings that match a given selector.

  <p class="note">
    A selector like ''p.foo:nth-child(even)'' means
    "of all the even siblings, select the <code>&lt;p></code> elements that have the class <code>foo</code>",
    because simple selectors match independently,
    rather than the sometimes-desired interpretation of
    "among the <code>&lt;p></code> elements with class <code>foo</code>, select the even ones".
    The '':nth-match()'' and '':nth-last-match()'' pseudo-classes
    allow one to build a selector for the latter interpretation.

  <p>In the <i>fast</i> Selectors profile, only lists of <i>compound selectors</i> are allowed within these selectors.
    In the <i>complete</i> profile, full <i>complex selectors</i> are allowed.

<h4 id="the-nth-match-pseudo">
<code>:nth-match()</code> pseudo-class</h4>

  <p>The <dfn id='nth-match-pseudo' title=":nth-match()">:nth-match(<var>An+B</var> of <var>&lt;selector></var>)</dfn> pseudo-class notation
    represents an element that has <var>An+B</var>-1 siblings
    that match the given <i>selector list</i>
    <em>before</em> it in the document tree.
    The CSS Syntax Module [[!CSS3SYN]] defines the <a href="http://dev.w3.org/csswg/css-syntax/#anb"><var>An+B</var> notation</a>.

<h4 id="the-nth-last-match-pseudo">
<code>:nth-last-match()</code> pseudo-class</h4>

  <p>The <dfn id='nth-last-match-pseudo' title=":nth-last-match()">:nth-last-match(<var>An+B</var> of <var>&lt;selector></var>)</dfn> pseudo-class notation
    represents an element that has <var>An+B</var>-1 siblings
    that match the given <i>selector list</i>
    <em>after</em> it in the document tree.
    The CSS Syntax Module [[!CSS3SYN]] defines the <a href="http://dev.w3.org/csswg/css-syntax/#anb"><var>An+B</var> notation</a>.


<h2 id="combinators">
Combinators</h2>

<h3 id="descendant-combinators">
Descendant combinator (<code> </code>)</h3>

  <p>At times, authors may want selectors to describe an element that is
  the descendant of another element in the document tree (e.g., "an
  <code>EM</code> element that is contained within an <code>H1</code>
  element"). Descendant combinators express such a relationship. A
  <dfn>descendant combinator</dfn> is <a href="#whitespace">whitespace</a> that
  separates two <i>compound selectors</i>.  A selector of the form
  "<code>A B</code>" represents an element <code>B</code> that is an
  arbitrary descendant of some ancestor element <code>A</code>.

  <div class="example">
    <p>Examples:
    <p>For example, consider the following selector:
    <pre>h1 em</pre>
    <p>It represents an <code>em</code> element being the descendant of
    an <code>h1</code> element. It is a correct and valid, but partial,
    description of the following fragment:
    <pre><!--
    -->&lt;h1>This &lt;span class="myclass">headline&#xa;<!--
    -->is &lt;em>very&lt;/em> important&lt;/span>&lt;/h1></pre>
    <p>The following selector:
    <pre>div * p</pre>
    <p>represents a <code>p</code> element that is a grandchild or later
    descendant of a <code>div</code> element. Note the whitespace on
    either side of the "*" is not part of the universal selector; the
    whitespace is a combinator indicating that the <code>div</code> must be the
    ancestor of some element, and that that element must be an ancestor
    of the <code>p</code>.
    <p>The following selector, which combines descendant combinators and
    <a href="#attribute-selectors">attribute selectors</a>, represents an
    element that (1) has the <code>href</code> attribute set and (2) is
    inside a <code>p</code> that is itself inside a <code>div</code>:
    <pre>div p *[href]</pre>
  </div>

<h3 id="child-combinators">
Child combinator (<code>></code>)</h3>

  <p>A <dfn>child combinator</dfn> describes a childhood relationship
  between two elements. A child combinator is made of the
  &quot;greater-than sign&quot; (U+003E, <code>></code>) code point and
  separates two <i>compound selectors</i>.


  <div class="example">
   <p>Examples:
   <p>The following selector represents a <code>p</code> element that is
   child of <code>body</code>:
   <pre>body > p</pre>
   <p>The following example combines descendant combinators and child
   combinators.
   <pre>div ol>li p</pre><!-- LEAVE THOSE SPACES OUT! see below -->
   <p>It represents a <code>p</code> element that is a descendant of an
   <code>li</code> element; the <code>li</code> element must be the
   child of an <code>ol</code> element; the <code>ol</code> element must
   be a descendant of a <code>div</code>. Notice that the optional white
   space around the ">" combinator has been left out.
  </div>

  <p>For information on selecting the first child of an element, please
  see the section on the <code><a
  href="#structural-pseudos">:first-child</a></code> pseudo-class
  above.

<h3 id="adjacent-sibling-combinators">
Next-sibling combinator (<code>+</code>)</h3>

  <p>The <dfn>next-sibling combinator</dfn> is made of the &quot;plus
  sign&quot; (U+002B, <code>+</code>) code point that separates two
  <i>compound selectors</i>.
  The elements represented by the two <i>compound selectors</i>
  share the same parent in the document tree
  and the element represented by the first <i>compound selector</i>
  immediately precedes the element represented by the second one.
  Non-element nodes (e.g. text between elements)
  are ignored when considering the adjacency of elements.

  <div class="example">
   <p>Examples:
   <p>The following selector represents a <code>p</code> element
   immediately following a <code>math</code> element:
   <pre>math + p</pre>
   <p>The following selector is conceptually similar to the one in the
   previous example, except that it adds an attribute selector &mdash; it
   adds a constraint to the <code>h1</code> element, that it must have
   <code>class="opener"</code>:
   <pre>h1.opener + h2</pre>
  </div>


<h3 id="general-sibling-combinators">
Following-sibling combinator (<code>~</code>)</h3>

  <p>The <dfn>following-sibling combinator</dfn> is made of the &quot;tilde&quot;
  (U+007E, <code>~</code>) code point that separates two <i>compound selectors</i>.
  The elements represented by the two <i>compound selectors</i> share
  the same parent in the document tree and the element represented by
  the first compound selector precedes (not necessarily immediately) the element
  represented by the second one.

  <div class="example">
   <p>Example:
   <pre>h1 ~ pre</pre>
   <p>represents a <code>pre</code> element following an <code>h1</code>. It
   is a correct and valid, but partial, description of:
   <pre>
  &lt;h1>Definition of the function a&lt;/h1>
  &lt;p>Function a(x) has to be applied to all figures in the table.&lt;/p>
  &lt;pre>function a(x) = 12x/13.5&lt;/pre></pre>
  </div>

<h3 id="idref-combinators">
Reference combinators <code>/ref/</code></h3>

  <p>
    The <dfn>reference combinator</dfn> consists of two slashes
    with an intervening <a href="http://www.w3.org/TR/css3-namespace/#css-qnames">CSS qualified name</a>,
    and separates two <i>compound selectors</i>,
    e.g. <code>A /attr/ B</code>.
    The element represented by the first <i>compound selector</i>
    explicitly references
    the element represented by the second <i>compound selector</i>.
    Unless the host language defines a different syntax for expressing this relationship,
    this relationship is considered to exist if
    the value of the specified attribute on the first element is an IDREF or an <i>ID selector</i>
    referencing the second element.

    Attribute matching for reference combinators follow the same rules as for <a href="http://www.w3.org/TR/css3-selectors/#attribute-selectors">attribute selectors</a>.

  <div class="example">
    <p>The following example highlights an <code>&lt;input></code> element
      when its
      <a href="http://www.w3.org/TR/html40/interact/forms.html#h-17.9"><code>&lt;label></code></a>
      is focused or hovered-over:
    <pre><!--
    -->label:matches(:hover, :focus) /for/ input,       /* association by "for" attribute */&#xa;<!--
    -->label:matches(:hover, :focus):not([for]) input { /* association by containment */&#xa;<!--
      -->box-shadow: yellow 0 0 10px; &#xa;<!--
    -->}</pre>
  </div>

<h2 id="table-pseudos">
Grid-Structural Selectors</h2>

  <p>The double-association of a cell in a 2D grid (to its row and column)
    cannot be represented by parentage in a hierarchical markup language.
    Only one of those associations can be represented hierarchically: the
    other must be explicitly or implicitly defined in the document language
    semantics. In both HTML and DocBook, two of the most common hierarchical
    markup languages, the markup is row-primary (that is, the row associations
    are represented hierarchically); the columns must be implied.
    To be able to represent such implied column-based relationships, the
    <i>column combinator</i> and the
    <code>:nth-column()</code> and <code>:nth-last-column()</code> pseudo-classes
    are defined.
    In a column-primary format, these pseudo-classes match against row associations instead.

<h3 id="column-combinator">
Column combinator</h3>

  <p>The <dfn>column combinator</dfn>, which consists of two pipes (''||'')
  represents the relationship of a column element
  to a cell element belonging to the column it represents.
  Column membership is determined based on the semantics of the document language only:
  whether and how the elements are presented is not considered.
  If a cell element belongs to more than one column,
  it is represented by a selector indicating membership in any of those columns.

  <div class="example">
    <p>The following example makes cells C, E, and G yellow.
    <pre>col.selected || td {
  background: gray;
  color: white;
  font-weight: bold;
}</pre>
    <pre><!--
    -->&lt;table>&#xa;<!--
    -->  &lt;col span="2">&#xa;<!--
    -->  &lt;col class="selected">&#xa;<!--
    -->  &lt;tr>&lt;td>A &lt;td>B &lt;td>C&#xa;<!--
    -->  &lt;tr>&lt;td colspan="2">D &lt;td>E&#xa;<!--
    -->  &lt;tr>&lt;td>F &lt;td colspan="2">G&#xa;<!--
    -->&lt;/table></pre>
  </div>

<h3 id="the-nth-column-pseudo">
<code>:nth-column()</code> pseudo-class</h3>

  <p>The <dfn id='nth-column-pseudo' title=":nth-column()">:nth-column(<var>An+B</var>)</dfn>
  pseudo-class notation represents a cell element belonging to a column
  that has <var>An+B</var>-1 columns
  <strong>before</strong> it, for any positive
  integer or zero value of <code>n</code>. Column membership is determined
  based on the semantics of the document language only: whether and how the
  elements are presented is not considered. If a cell element belongs to
  more than one column, it is represented by a selector indicating any of
  those columns.

  <p>The CSS Syntax Module [[!CSS3SYN]] defines the <a href="http://dev.w3.org/csswg/css-syntax/#anb"><var>An+B</var> notation</a>.



<h3 id="the-nth-last-column-pseudo">
<code>:nth-last-column()</code> pseudo-class</h3>

  <p>The <dfn id='nth-last-column-pseudo' title=":nth-last-column()">:nth-last-column(<var>An+B</var>)</dfn>
  pseudo-class notation represents a cell element belonging to a column
  that has <var>An+B</var>-1 columns
  <strong>after</strong> it, for any positive
  integer or zero value of <code>n</code>. Column membership is determined
  based on the semantics of the document language only: whether and how the
  elements are presented is not considered. If a cell element belongs to
  more than one column, it is represented by a selector indicating any of
  those columns.

  <p>The CSS Syntax Module [[!CSS3SYN]] defines the <a href="http://dev.w3.org/csswg/css-syntax/#anb"><var>An+B</var> notation</a>.

<h2 id="specificity">
Calculating a selector's specificity</h2>

  <p>A selector's specificity is calculated for a given element as follows:

  <ul>
    <li>count the number of ID selectors in the selector (= <var title=''>A</var>)
    <li>count the number of class selectors, attributes selectors, and pseudo-classes in the selector (= <var title=''>B</var>)
    <li>count the number of type selectors and pseudo-elements in the selector (= <var title=''>C</var>)
    <li>ignore the universal selector
  </ul>

  <p>
    In most cases, a selector has the same specificity for every element it applies to.
    The specificity of a <a href="#matches">:matches()</a> pseudo-class, however,
    is the specificity of the most specific complex selector that matched the given element.
    (The full selector's specificity is equivalent to expanding out all the combinations in full, without <code>:matches()</code>.)
    The specificity of a <a href="#negation">:not()</a> pseudo-class is
    the specificity of the most specifc complex selector in its selector list.
    In either case, the pseudo-class itself does not contribute any additional specificity.
    For example, <code>:matches(em, strong)</code> has a specificity of (0,0,1), like a tag selector.

  <p>
    Specificities are compared by comparing the three components in order:
    the specificity with a larger <var title=''>A</var> value is more specific;
    if the two <var title=''>A</var> values are tied,
    then the specificity with a larger <var title=''>B</var> value is more specific;
    if the two <var title=''>B</var> values are also tied,
    then the specificity with a larger <var title=''>C</var> value is more specific;
    if all the values are tied,
    the two specifities are equal.

  <p>
    Due to storage limitations,
    implementations may have limitations on the size of <var title=''>A</var>, <var title=''>B</var>, or <var title=''>C</var>.
    If so, values higher than the limit must be clamped to that limit,
    and not overflow.

  <div class="example">
    <p>Examples:
    <pre><!--
    -->*               /* a=0 b=0 c=0 */&#xa;<!--
    -->LI              /* a=0 b=0 c=1 */&#xa;<!--
    -->UL LI           /* a=0 b=0 c=2 */&#xa;<!--
    -->UL OL+LI        /* a=0 b=0 c=3 */&#xa;<!--
    -->H1 + *[REL=up]  /* a=0 b=1 c=1 */&#xa;<!--
    -->UL OL LI.red    /* a=0 b=1 c=3 */&#xa;<!--
    -->LI.red.level    /* a=0 b=2 c=1 */&#xa;<!--
    -->#x34y           /* a=1 b=0 c=0 */&#xa;<!--
    -->#s12:not(FOO)   /* a=1 b=0 c=1 */&#xa;<!--
    -->.foo :matches(.bar, #baz)&#xa;<!--
    -->                /* Either a=1 b=1 c=0&#xa;<!--
    -->                   or a=0 b=2 c=0, depending&#xa;<!--
    -->                   on the element being matched. */</pre>

  </div>

  <p class="note"><strong>Note:</strong> Repeated occurrences of the
  same simple selector are allowed and do increase specificity.

  <p class="note"><strong>Note:</strong> The specificity of the styles
  specified in an HTML <code>style</code> attribute <a href="http://www.w3.org/TR/css-style-attr/#interpret">is described in CSS Style Attributes</a>. [[CSSSTYLEATTR]]

<h2 id="grammar"><a id="formal-syntax"></a>
Grammar</h2>

  <p>
    The grammar below defines the syntax of Selectors.
    It is applied to a stream of tokens,
    as returned by the tokenizer defined in [[!CSS3SYN]].
    It is globally LL(1) and can be locally LL(2)
    (but note that most UAs should not use it directly,
    since it doesn't express the parsing conventions).
    The format of the productions is optimized for human consumption
    and some shorthand notations beyond Yacc (see [[!YACC]]) are used:

  <ul>
    <li><b>*</b>: 0 or more
    <li><b>+</b>: 1 or more
    <li><b>?</b>: 0 or 1
    <li><b>|</b>: separates alternatives
    <li><b>[ ]</b>: grouping
  </ul>

  <p>
    The productions in uppercase are defined by CSS Syntax [[!CSS3SYN]],
    and correspond to the tokens of the same name.
    Literal strings correspond to delim tokens with the given value.
    Unlike other grammars in CSS, whitespace is not ignored
    The production "S" represents a whitespace token.
    The wqname_prefix production comes from the Namespaces spec [[!CSS3NAMESPACE]]

  <p>The productions are:

  <pre>
    <dfn>complex_selector_list</dfn>
      : complex_selector [ COMMA S* complex_selector ]*
      ;

    <dfn>scope_relative_selector_list</dfn>
      : scope_relative_selector [ COMMA s* scope_relative_selector ]*

    <dfn>scope_relative_selector</dfn>
      : combinator? complex_selector
      ;

    <dfn>complex_selector</dfn>
      : compound_selector [ combinator compound_selector ]* S*
      ;

    <dfn>combinator</dfn>
      /* combinators can be surrounded by whitespace */
      : S+ | S* [ '>' | '+' | '~' | COLUMN | '/' IDENT '/' ] S*
      ;

    <dfn>compound_selector_list</dfn>
      : compound_selector S* [ COMMA S* compound_selector ]* S*

    <dfn>compound_selector</dfn>
      : type_selector [ id | class | attrib | pseudo ]*
        | [ id | class | attrib | pseudo ]+
      ;

    <dfn>simple_selector_list</dfn>
      : simple_selector S* [ COMMA S* simple_selector ] S*

    <dfn>simple_selector</dfn>
      : type_selector | id | class | attrib | pseudo

    <dfn>type_selector</dfn>
      : wqname_prefix? element_name
      ;

    element_name
      : IDENT | '*'
      ;

    id
      : HASH
      ;

    class
      : '.' IDENT
      ;

    attrib
      : '[' S* attrib_name ']'
        | '[' S* attrib_name attrib_match [ IDENT | STRING ] S* attrib_flags? ']'
      ;

    attrib_name
      : wqname_prefix? IDENT S*

    attrib_match
      : [ '=' |
          PREFIX-MATCH |
          SUFFIX-MATCH |
          SUBSTRING-MATCH |
          INCLUDE-MATCH |
          DASH-MATCH
        ] S*

    attrib_flags
      : IDENT S*

    pseudo
      /* '::' starts a pseudo-element, ':' a pseudo-class */
      /* Exceptions: :first-line, :first-letter, :before and :after. */
      /* Note that pseudo-elements are restricted to one per selector and */
      /* occur only in the last compound_selector. */
      : ':' ':'? [ IDENT | functional_pseudo ]
      ;

    functional_pseudo
      : FUNCTION S* value ')'
      ;</pre>

  <p>
    To aid with the authoring of property grammars,
    the following CSS grammar productions are defined:

  <dl>
    <dt><dfn><var>&lt;selector></var></dfn>
    <dd>
      A <code>complex_selector_list</code> production representing
      a <i>selector list</i>.

    <dt><dfn><var>&lt;relative-selector></var></dfn>
    <dd>
      A <code>scope_relative_selector_list</code> production representing
      a <i>selector list</i> comprised of <i>relative selectors</i>.

    <dt><dfn><var>&lt;compound-selector></var></dfn>
    <dd>
      A <code>compound_selector_list</code> production representing
      a <i>selector list</i> comprised of <i>compound selectors</i>.

    <dt><dfn><var>&lt;id-selector></var></dfn>
    <dd>
      An <code>id</code> production representing
      an <i>ID selector</i>
  </dl>

<h2 id='api-hooks'>
API Hooks</h2>

  <p>
    To aid in the writing of specs that use Selectors concepts,
    this section defines several API hooks that can be invoked by other specifications.

<h3 id='parse-a-selector'>
Parse A Selector</h3>

  <p>
    This section defines how to <dfn>parse a selector</dfn> from a string <var>source</var>.
    It returns either a complex selector list,
    or failure.

  <ol>
    <li>
      Let <var title=''>selector</var> be the result of parsing <var>source</var> against the <code>complex_selector_list</code> grammar.
      If it does not match the grammar,
      return failure.

    <li>
      Otherwise,
      if any simple selectors in <var title=''>selector</var> are not recognized by the user agent,
      or <var title=''>selector</var> is otherwise invalid in some way
      (such as, for example, containing an undeclared namespace prefix),
      return failure.

    <li>
      Otherwise,
      return <var title=''>selector</var>.
  </ol>

<h3 id='parse-a-relative-selector'>
Parse A Relative Selector</h3>

  <p>
    This section defines how to <dfn>parse a relative selector</dfn> from a string <var>source</var>,
    against a <i>reference element set</i> <var>refs</var>.
    The reference element set must contain zero or more elements,
    or a single virtual scoping root,
    such as a <code>Document</code> or <code>Document Fragment</code>.
    It returns either a complex selector list,
    or failure.

  <ol>
    <li>
      Let <var title=''>selector</var> be the result of parsing <var>source</var> against the <code>scope_relative_selector_list</code> grammar.
      If it does not match the grammar,
      return failure.

    <li>
      Otherwise,
      if any simple selectors in <var title=''>selector</var> are not recognized by the user agent,
      or <var title=''>selector</var> is otherwise invalid in some way
      (such as, for example, containing an undeclared namespace prefix),
      return failure.

    <li>
      Otherwise,
      <i title="absolutize a relative selector list">absolutize <var title=''>selector</var></i> with <var>refs</var> as the <i>reference element set</i>.

    <li>
      Return <var title=''>selector</var>.
  </ol>

<h3 id='match-a-selector'>
Match A Selector</h3>

  <p>
    This section describes how to <dfn>match a selector</dfn> <var title=''>selector</var> against a tree of nodes <var>nodes</var>.
    Optionally, a <i>scoping root</i> and scoping method (<i>scope-contained</i> or <i>scope-filtered</i>) may be provided.
    Optionally, an explicit <i>reference element set</i> <var>element set</var> (which may be empty) may be provided.
    It returns a list of zero or more elements.

  <p>
    If an explicit <i>reference element set</i> is given,
    this algorithm may be called without specifying a tree of nodes.
    (The tree will be inferred from each element in the set;
    this makes it easier to invoke the algorithm for a relative selector.)

  <ol>
    <li>
      If no explicit <i>reference element set</i> was given,
      return the result of matching <var title=''>selector</var> against <var>nodes</var>,
      with the <i>scoping root</i> and scoping method if they were provided.

    <li>
      Otherwise,
      let <var>result</var> initially be the empty list.

    <li>
      For each element <var>reference element</var> in <var>element set</var>:

      <ol>
        <li>
          If <var>nodes</var> was not given,
          let <var>nodes</var> be all the nodes in the same tree as <var>reference element</var>.

        <li>
          Let <var>single result</var> be the result of matching <var title=''>selector</var> against <var>nodes</var>,
          with the <i>scoping root</i> and scoping method if they were provided,
          and <var>reference element</var> as the <i>reference element set</i>.

        <li>
          Append each element in <var>single result</var> to <var>result</var>,
          unless the element is already present in <var>result</var>.
      </ol>

    <li>
      Return <var>result</var>.
  </ol>



<h2 id="changes">
Changes</h2>

  <p>Significant changes since the <a href="http://www.w3.org/TR/2013/WD-selectors4-20130502/">2 MaY 2013 Working Draft</a> include:
  <ul>
    <li>Split out <i>relative selectors</i> from <i>scoped selectors</i>,
      as these are different concepts that can be independently invoked.
  </ul>

<h2 id="conformance">
Conformance</h2>

<h3 id="conventions">Document Conventions</h3>

  <p>Conformance requirements are expressed with a combination of
  descriptive assertions and RFC 2119 terminology. The key words “MUST”,
  “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
  “RECOMMENDED”, “MAY”, and “OPTIONAL” in the normative parts of this
  document are to be interpreted as described in RFC 2119.
  However, for readability, these words do not appear in all uppercase
  letters in this specification.

  <p>All of the text of this specification is normative except sections
  explicitly marked as non-normative, examples, and notes. [[!RFC2119]]

  <p>Examples in this specification are introduced with the words “for example”
  or are set apart from the normative text with <code>class="example"</code>,
  like this:

  <div class="example">
    <p>This is an example of an informative example.
  </div>

  <p>Informative notes begin with the word “Note” and are set apart from the
  normative text with <code>class="note"</code>, like this:

  <p class="note">Note, this is an informative note.

<h3 id="conformance-classes">
Conformance Classes</h3>

  <p>Conformance to Selectors Level 4
  is defined for three conformance classes:
  <dl>
    <dt><dfn title="selector instance!!as conformance class">selector instance</dfn>
      <dd>A written selector.
    <dt><dfn>interpreter</dfn>
      <dd>A <a href="http://www.w3.org/TR/CSS21/conform.html#user-agent">UA</a>
      that interprets the semantics of a selector.
    <dt><dfn id="authoring-tool">authoring tool</dfn>
      <dd>A <a href="http://www.w3.org/TR/CSS21/conform.html#user-agent">UA</a>
      that writes a style sheet.
  </dl>

  <p>A selector instance is conformant to Selectors Level 4 if it is valid
    according to the selector syntax rules defined in this specification.

  <p>An interpreter is conformant to Selectors Level 4
  if it parses interprets selectors according to the semantics defined in
  Selectors Level 4 (including following the error-handling rules). However,
  the inability of a user agent to implement part of this specification due to
  the limitations of a particular device (e.g., non interactive user agents will
  probably not implement dynamic pseudo-classes because they make no sense
  without interactivity) does not imply non-conformance.

  <p>An authoring tool is conformant to Selectors Level 4
  if it writes syntactically correct selectors.

  <p>Any specification reusing Selectors must define
  the subset of Selectors it accepts or excludes,
  and describe any additional constraints
  it adds to the current specification.

  <p>Specifications reusing Selectors must define how to handle invalid
  selectors. (In the case of CSS, the entire rule in which the selector is
  used is effectively dropped.)

<h3 id="partial">
Partial Implementations</h3>

  <p>So that authors can exploit the forward-compatible parsing rules to
  trigger fallback behavior, UAs <strong>must</strong>
  treat as <a href="#invalid">invalid</a> any selectors for which they have
  no usable level of support.

<h3 id="experimental">
Experimental Implementations</h3>

  <p>To avoid clashes with future Selectors features, the Selectors specification
  reserves a <a href="http://www.w3.org/TR/CSS21/syndata.html#vendor-keywords">prefixed
  syntax</a> for proprietary extensions to Selectors. The CSS Working Group
  recommends that experimental implementations of features in Selectors Working
  Drafts also use vendor-prefixed pseudo-element or pseudo-class names. This
  avoids any incompatibilities with future changes in the draft. Once a
  specification reaches the Candidate Recommendation stage, implementors
  should implement the non-prefixed syntax for any feature they consider to
  be correctly implemented according to spec.

<!--
  <h2 id="Tests">Tests</h2>

  <p>This specification has <a
  href="http://www.w3.org/Style/CSS/Test/CSS3/Selectors/current/">a test
  suite</a> allowing user agents to verify their basic conformance to
  the specification. This test suite does not pretend to be exhaustive
  and does not cover all possible combined cases of Selectors.
-->

<h2 id="acknowledgements">
Acknowledgements</h2>

  <p>The CSS working group would like to thank everyone who contributed
  to the <a href="http://www.w3.org/TR/css3-selectors">previous Selectors</a>
  specifications over the years, as those specifications formed the basis
  for this one.
  <p>In particular, the working group would like to extend special
  thanks to the following for their specific contributions to Selectors
  Level 4:
  L. David Baron,
  Andrew Fedoniouk,
  Ian Hickson,
  Grey Hodge,
  Lachlan Hunt,
  Jason Cranford Teague

<h2 id="references">
References</h2>

<h3 id="normative-references">
Normative References</h3>
<!--normative-->

<h3 id="informative-references">
Informative References</h3>
<!--informative-->


</body>
</html>

